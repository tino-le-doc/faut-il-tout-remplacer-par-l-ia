<!DOCTYPE html>
<html lang="fr">
<head>
    <!--
      Copyright (c) 2025 TLD - Tous droits reserves
      Toute copie, reproduction ou reutilisation non autorisee est interdite.
      Licence proprietaire - voir fichier LICENSE
    -->
    <meta charset="UTF-8">
    <meta http-equiv="content-language" content="fr">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8612974241235499"
         crossorigin="anonymous"></script>
    <meta name="author" content="TLD">
    <meta name="copyright" content="Copyright 2025 TLD. Tous droits reserves.">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content">
    <meta name="theme-color" content="#0a0a0f">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="img/1000074494.png">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="192x192" href="img/1000074494.png">
    <meta name="description" content="Messagerie privee TLD. Envoyez des messages prives aux membres de la communaute.">
    <meta property="og:title" content="Messagerie - TLD">
    <meta property="og:description" content="Envoyez des messages prives aux membres de la communaute TLD.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://tino-le-doc.com/messagerie.html">
    <meta property="og:locale" content="fr_FR">
    <meta property="og:image" content="https://tino-le-doc.com/img/1000074494.png">
    <title>Messagerie ðŸ’¬ TLD</title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&family=Syne:wght@700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/common.css">
    <style>
        :root {
            --bg: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a25;
            --cyan: #00f5ff;
            --magenta: #ff00aa;
            --orange: #ff9500;
            --yellow: #f5ff00;
            --green: #00ff88;
            --red: #ff4444;
            --text: #e8e8e8;
            --text-secondary: #a0a0a0;
            --glass: rgba(255,255,255,0.05);
            --glass-border: rgba(255,255,255,0.1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            min-height: 100dvh;
            overflow: hidden;
        }

        /* Layout */
        .app-container {
            display: flex;
            height: 100vh;
            height: 100dvh;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Sidebar */
        .sidebar {
            width: 320px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(180deg, rgba(0, 245, 255, 0.03), transparent);
        }

        .sidebar-header h1 {
            font-family: 'Syne', sans-serif;
            font-size: 1.3rem;
            background: linear-gradient(135deg, var(--cyan), var(--magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .icon-btn {
            width: 36px;
            height: 36px;
            border: none;
            background: var(--glass);
            border-radius: 10px;
            color: var(--text);
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-btn:hover {
            background: var(--cyan);
            color: var(--bg);
        }

        .icon-btn.danger:hover {
            background: var(--red);
        }

        /* Tabs */
        .sidebar-tabs {
            display: flex;
            border-bottom: 1px solid var(--glass-border);
        }

        .tab-btn {
            flex: 1;
            padding: 12px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-family: 'Syne', sans-serif;
            font-weight: 700;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .tab-btn:hover {
            color: var(--text);
            background: var(--glass);
        }

        .tab-btn.active {
            color: var(--cyan);
        }

        .tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 20%;
            width: 60%;
            height: 3px;
            background: var(--cyan);
            border-radius: 3px 3px 0 0;
        }

        .tab-btn .badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 18px;
            height: 18px;
            padding: 0 5px;
            background: var(--magenta);
            border-radius: 10px;
            font-size: 0.7rem;
            color: white;
            margin-left: 5px;
        }

        /* Search */
        .search-box {
            padding: 15px;
            border-bottom: 1px solid var(--glass-border);
        }

        .search-input {
            width: 100%;
            padding: 11px 16px;
            background: var(--bg-tertiary);
            border: 2px solid var(--glass-border);
            border-radius: 14px;
            color: var(--text);
            font-family: inherit;
            font-size: 0.9rem;
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--cyan);
            box-shadow: 0 0 12px rgba(0, 245, 255, 0.1);
        }

        .search-input::placeholder {
            color: var(--text-secondary);
        }

        /* Conversations List */
        .conversations-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .conversations-list::-webkit-scrollbar {
            width: 5px;
        }

        .conversations-list::-webkit-scrollbar-thumb {
            background: var(--glass-border);
            border-radius: 5px;
        }

        .conv-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.25s ease;
            margin-bottom: 5px;
            border: 1px solid transparent;
        }

        .conv-item:hover {
            background: var(--glass);
            border-color: var(--glass-border);
            transform: translateX(4px);
        }

        .conv-item.active {
            background: linear-gradient(135deg, rgba(0,245,255,0.12), rgba(255,0,170,0.12));
            border: 1px solid rgba(0, 245, 255, 0.4);
            box-shadow: 0 2px 12px rgba(0, 245, 255, 0.1);
        }

        .conv-item.unread {
            background: rgba(255,0,170,0.08);
            border-color: rgba(255,0,170,0.2);
        }

        .conv-avatar {
            width: 48px;
            height: 48px;
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.2rem;
            flex-shrink: 0;
            position: relative;
        }

        .conv-avatar.user {
            background: linear-gradient(135deg, var(--orange), var(--yellow));
            color: var(--bg);
        }

        .conv-avatar.group {
            background: linear-gradient(135deg, var(--cyan), var(--magenta));
            color: white;
        }

        .online-indicator {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            background: var(--green);
            border: 2px solid var(--bg-secondary);
            border-radius: 50%;
        }

        .conv-info {
            flex: 1;
            min-width: 0;
        }

        .conv-name {
            font-weight: 700;
            font-size: 0.95rem;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .conv-name .group-icon {
            font-size: 0.8rem;
        }

        .conv-preview {
            font-size: 0.8rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .conv-meta {
            text-align: right;
            flex-shrink: 0;
        }

        .conv-time {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .conv-unread {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 20px;
            height: 20px;
            padding: 0 6px;
            background: var(--magenta);
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 700;
            color: white;
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }

        .empty-state .icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }

        .empty-state h3 {
            font-family: 'Syne', sans-serif;
            color: var(--text);
            margin-bottom: 10px;
        }

        /* Main Chat Area */
        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg);
            height: 100vh;
            height: 100dvh;
            min-height: 0;
            overflow: hidden;
            position: relative;
        }

        .chat-header {
            padding: 15px 20px;
            background: linear-gradient(180deg, var(--bg-secondary), rgba(18, 18, 26, 0.95));
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            gap: 15px;
            flex-shrink: 0;
            backdrop-filter: blur(10px);
        }

        .chat-header-info {
            flex: 1;
        }

        .chat-header-name {
            font-family: 'Syne', sans-serif;
            font-size: 1.1rem;
            font-weight: 700;
        }

        .chat-header-status {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .chat-header-status.online {
            color: var(--green);
        }

        .chat-header-actions {
            display: flex;
            gap: 8px;
        }

        /* Messages */
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-height: 0;
            background-image:
                radial-gradient(circle at 20% 80%, rgba(255, 0, 170, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 245, 255, 0.03) 0%, transparent 50%);
        }

        .messages-container::-webkit-scrollbar {
            width: 6px;
        }

        .messages-container::-webkit-scrollbar-thumb {
            background: var(--cyan);
            border-radius: 3px;
        }

        .message {
            display: flex;
            gap: 10px;
            max-width: 70%;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.own {
            flex-direction: row-reverse;
            margin-left: auto;
        }

        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.9rem;
            flex-shrink: 0;
            background: linear-gradient(135deg, var(--orange), var(--yellow));
            color: var(--bg);
        }

        .message.own .message-avatar {
            background: linear-gradient(135deg, var(--magenta), var(--cyan));
            color: white;
        }

        .message-content {
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            border-radius: 18px 18px 18px 4px;
            padding: 12px 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .message.own .message-content {
            background: linear-gradient(135deg, rgba(255,0,170,0.15), rgba(0,245,255,0.15));
            border: 1px solid rgba(0, 245, 255, 0.2);
            border-radius: 18px 18px 4px 18px;
            box-shadow: 0 2px 8px rgba(0, 245, 255, 0.1);
        }

        .message-sender {
            font-weight: 700;
            font-size: 0.85rem;
            color: var(--orange);
            margin-bottom: 4px;
        }

        .message.own .message-sender {
            color: var(--cyan);
        }

        .message-text {
            line-height: 1.5;
            word-wrap: break-word;
        }

        .message-text img {
            max-width: 200px;
            max-height: 150px;
            border-radius: 10px;
            margin-top: 8px;
        }

        .message-time {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 5px;
            text-align: right;
        }

        .message-system {
            text-align: center;
            padding: 10px;
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-style: italic;
        }

        .message-system.join { color: var(--green); }
        .message-system.leave { color: var(--red); }

        /* Input Area */
        .input-area {
            padding: 15px 20px;
            padding-bottom: calc(15px + env(safe-area-inset-bottom, 0px));
            background: var(--bg-secondary);
            border-top: 1px solid var(--glass-border);
            flex-shrink: 0;
            z-index: 10;
        }

        .input-toolbar {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .input-form {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .input-form input {
            flex: 1;
            padding: 14px 20px;
            background: var(--bg-tertiary);
            border: 2px solid var(--glass-border);
            border-radius: 25px;
            color: var(--text);
            font-family: inherit;
            font-size: 1rem;
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        .input-form input:focus {
            outline: none;
            border-color: var(--cyan);
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.15);
        }

        .input-form input::placeholder {
            color: var(--text-secondary);
        }

        .input-form button {
            width: 48px;
            height: 48px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, var(--magenta), var(--cyan));
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
            flex-shrink: 0;
            box-shadow: 0 4px 15px rgba(255, 0, 170, 0.3);
        }

        .input-form button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 25px rgba(255, 0, 170, 0.5);
        }

        .input-form button:active {
            transform: scale(0.95);
        }

        /* Emoji Picker */
        .emoji-btn {
            width: 48px;
            height: 48px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--glass);
            border: 2px solid var(--glass-border);
            border-radius: 50%;
            color: var(--text);
            font-size: 1.3rem;
            cursor: pointer;
            transition: all 0.3s;
            flex-shrink: 0;
        }

        .emoji-btn:hover {
            border-color: var(--cyan);
            transform: scale(1.1);
        }

        .emoji-picker {
            display: none;
            position: absolute;
            bottom: 70px;
            left: 15px;
            width: 320px;
            max-height: 350px;
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 100;
            overflow: hidden;
        }

        .emoji-picker.open {
            display: flex;
            flex-direction: column;
        }

        .emoji-categories {
            display: flex;
            gap: 2px;
            padding: 8px;
            border-bottom: 1px solid var(--glass-border);
            overflow-x: auto;
        }

        .emoji-cat-btn {
            padding: 6px 8px;
            background: none;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .emoji-cat-btn:hover,
        .emoji-cat-btn.active {
            background: var(--glass);
        }

        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            padding: 8px;
            overflow-y: auto;
            max-height: 280px;
        }

        .emoji-grid span {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            padding: 6px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s, transform 0.15s;
        }

        .emoji-grid span:hover {
            background: var(--glass);
            transform: scale(1.2);
        }

        @media (max-width: 768px) {
            .emoji-picker {
                width: calc(100vw - 30px);
                left: 15px;
                bottom: 65px;
            }
            .emoji-grid {
                grid-template-columns: repeat(7, 1fr);
            }
        }

        /* No Chat Selected */
        .no-chat {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 40px;
            background-image:
                radial-gradient(circle at 50% 50%, rgba(0, 245, 255, 0.05) 0%, transparent 60%);
        }

        /* Active Chat - IMPORTANT: doit prendre toute la hauteur */
        #activeChat {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0;
        }

        .no-chat .icon {
            font-size: 5rem;
            margin-bottom: 20px;
        }

        .no-chat h2 {
            font-family: 'Syne', sans-serif;
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .no-chat p {
            color: var(--text-secondary);
            max-width: 300px;
        }

        /* Modals */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            width: 100%;
            max-width: 450px;
            max-height: 80vh;
            overflow: hidden;
            animation: modalIn 0.3s ease;
        }

        @keyframes modalIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modal-header h2 {
            font-family: 'Syne', sans-serif;
            font-size: 1.2rem;
        }

        .modal-close {
            width: 32px;
            height: 32px;
            border: none;
            background: var(--glass);
            border-radius: 8px;
            color: var(--text);
            font-size: 1.2rem;
            cursor: pointer;
        }

        .modal-close:hover {
            background: var(--red);
        }

        .modal-body {
            padding: 20px;
            max-height: 50vh;
            overflow-y: auto;
        }

        .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid var(--glass-border);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 12px 15px;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            color: var(--text);
            font-family: inherit;
            font-size: 1rem;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--cyan);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 12px;
            font-family: 'Syne', sans-serif;
            font-weight: 700;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--magenta), var(--cyan));
            color: white;
        }

        .btn-secondary {
            background: var(--glass);
            color: var(--text);
            border: 1px solid var(--glass-border);
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        /* User/Contact item */
        .user-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--glass);
            border-radius: 12px;
            margin-bottom: 10px;
        }

        .user-item-avatar {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            background: linear-gradient(135deg, var(--orange), var(--yellow));
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: var(--bg);
        }

        .user-item-info {
            flex: 1;
        }

        .user-item-name {
            font-weight: 700;
        }

        .user-item-status {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .user-item-actions {
            display: flex;
            gap: 5px;
        }

        .user-item-actions button {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .user-item-actions .accept {
            background: var(--green);
            color: var(--bg);
        }

        .user-item-actions .reject {
            background: var(--red);
            color: white;
        }

        .user-item-actions .add {
            background: var(--cyan);
            color: var(--bg);
        }

        .user-item-actions .message {
            background: var(--magenta);
            color: white;
        }

        /* Members list */
        .members-section {
            margin-top: 20px;
        }

        .members-section h4 {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .member-chip {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: var(--glass);
            border-radius: 20px;
            margin: 3px;
            font-size: 0.85rem;
        }

        .member-chip .remove {
            width: 18px;
            height: 18px;
            border: none;
            background: var(--red);
            border-radius: 50%;
            color: white;
            font-size: 0.7rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Login required */
        .login-required {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            height: 100dvh;
            text-align: center;
            padding: 40px;
            background-image:
                radial-gradient(circle at 30% 40%, rgba(255, 0, 170, 0.06) 0%, transparent 50%),
                radial-gradient(circle at 70% 60%, rgba(0, 245, 255, 0.06) 0%, transparent 50%);
        }

        .login-required .icon {
            font-size: 5rem;
            margin-bottom: 20px;
            animation: float1 3s ease-in-out infinite;
        }

        @keyframes loginFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .login-required h1 {
            font-family: 'Syne', sans-serif;
            font-size: 2rem;
            margin-bottom: 15px;
            background: linear-gradient(135deg, var(--cyan), var(--magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .login-required p {
            color: var(--text-secondary);
            margin-bottom: 30px;
            max-width: 400px;
            line-height: 1.6;
        }

        .login-required .btn {
            padding: 15px 40px;
            font-size: 1.1rem;
            box-shadow: 0 6px 25px rgba(255, 0, 170, 0.3);
        }

        .login-required .btn:hover {
            box-shadow: 0 8px 35px rgba(255, 0, 170, 0.5);
        }

        /* ===== RESPONSIVE MOBILE (Android / iOS) ===== */
        @media (max-width: 768px) {
            body { height: 100dvh; overflow: hidden; }

            .app-container {
                flex-direction: column;
                height: 100dvh;
            }

            /* Sidebar en overlay plein ecran */
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                bottom: 0;
                width: 100%;
                z-index: 100;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }

            .sidebar.open {
                transform: translateX(0);
            }

            /* Overlay sombre derriere la sidebar */
            .sidebar-overlay {
                display: none;
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.6);
                z-index: 99;
            }

            .sidebar-overlay.active {
                display: block;
            }

            /* Header mobile */
            .mobile-header {
                display: flex;
                align-items: center;
                padding: 10px 15px;
                background: var(--bg-secondary);
                border-bottom: 1px solid var(--glass-border);
                flex-shrink: 0;
                gap: 12px;
                min-height: 50px;
            }

            .mobile-header .icon-btn {
                width: 44px;
                height: 44px;
                font-size: 1.3rem;
            }

            .mobile-header span {
                font-family: 'Syne', sans-serif;
                font-size: 1rem;
                font-weight: 700;
            }

            /* Zone de chat - prend l'espace restant apres mobile-header */
            .chat-area {
                width: 100%;
                flex: 1;
                min-height: 0;
                height: 0;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                position: relative;
            }

            #activeChat {
                flex: 1;
                display: flex;
                flex-direction: column;
                min-height: 0;
                height: 0;
                overflow: hidden;
            }

            .messages-container {
                flex: 1;
                min-height: 0;
                max-height: none;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* Chat header mobile */
            .chat-header {
                padding: 10px 12px;
                gap: 10px;
            }

            .chat-header .conv-avatar {
                width: 36px;
                height: 36px;
                font-size: 0.9rem;
                border-radius: 10px;
            }

            .chat-header-name { font-size: 0.95rem; }
            .chat-header-status { font-size: 0.75rem; }

            #mobileBackBtn {
                display: flex !important;
                width: 44px;
                height: 44px;
                font-size: 1.2rem;
            }

            /* Messages */
            .messages-container {
                flex: 1;
                min-height: 0;
                padding: 12px;
                gap: 10px;
                -webkit-overflow-scrolling: touch;
            }

            .message { max-width: 85%; }

            .message-avatar {
                width: 32px;
                height: 32px;
                font-size: 0.8rem;
                border-radius: 8px;
            }

            .message-content {
                padding: 10px 12px;
                border-radius: 14px 14px 14px 4px;
            }

            .message.own .message-content {
                border-radius: 14px 14px 4px 14px;
            }

            .message-sender { font-size: 0.8rem; }
            .message-text { font-size: 0.92rem; }
            .message-text img { max-width: 180px; max-height: 120px; }
            .message-time { font-size: 0.65rem; }

            /* Zone de saisie - toujours visible en bas */
            .input-area {
                padding: 10px 12px;
                padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
                flex-shrink: 0;
                position: relative;
                background: var(--bg-secondary);
                border-top: 1px solid var(--glass-border);
                z-index: 10;
            }

            .input-toolbar { margin-bottom: 8px; }

            .input-toolbar .icon-btn {
                width: 44px;
                height: 44px;
            }

            .input-form { gap: 8px; }

            .input-form input {
                padding: 12px 16px;
                font-size: 16px;
                border-radius: 22px;
            }

            .input-form button {
                width: 48px;
                height: 48px;
                padding: 0;
                font-size: 1.2rem;
                border-radius: 50%;
                min-width: 48px;
                min-height: 48px;
            }

            /* Boutons tactiles globaux min 44px */
            .icon-btn {
                width: 44px;
                height: 44px;
                font-size: 1.2rem;
            }

            .tab-btn {
                padding: 12px 8px;
                font-size: 0.8rem;
                min-height: 44px;
            }

            /* Sidebar contenu mobile */
            .sidebar-header { padding: 15px; }
            .sidebar-header h1 { font-size: 1.1rem; }

            .search-input {
                padding: 12px 15px;
                font-size: 16px;
            }

            .conv-item {
                padding: 12px;
                gap: 10px;
                min-height: 60px;
            }

            .conv-avatar {
                width: 44px;
                height: 44px;
                font-size: 1.1rem;
            }

            .conv-name { font-size: 0.9rem; }
            .conv-preview { font-size: 0.8rem; }

            /* No chat selected */
            .no-chat { padding: 30px 20px; }
            .no-chat .icon { font-size: 3rem; }
            .no-chat h2 { font-size: 1.2rem; }
            .no-chat p { font-size: 0.9rem; }

            /* Login required */
            .login-required { padding: 30px 20px; }
            .login-required .icon { font-size: 3.5rem; }
            .login-required h1 { font-size: 1.5rem; }
            .login-required p { font-size: 0.9rem; }
            .login-required .btn { padding: 14px 30px; font-size: 1rem; min-height: 48px; }

            /* Modals sur mobile */
            .modal-overlay { padding: 10px; }
            .modal { border-radius: 15px; max-height: 90vh; }
            .modal-header { padding: 15px; }
            .modal-header h2 { font-size: 1rem; }
            .modal-body { padding: 15px; }
            .modal-footer { padding: 12px 15px; }

            .form-group input,
            .form-group textarea {
                font-size: 16px;
                padding: 12px 15px;
            }

            .btn { min-height: 44px; padding: 12px 20px; }

            .user-item { padding: 10px; gap: 10px; }
            .user-item-actions button { min-height: 36px; min-width: 44px; padding: 8px 14px; }
        }

        /* Petits ecrans Android */
        @media (max-width: 380px) {
            .sidebar-header h1 { font-size: 1rem; }
            .chat-header-name { font-size: 0.85rem; }
            .conv-avatar { width: 38px; height: 38px; font-size: 1rem; }
            .message { max-width: 90%; }
            .message-avatar { width: 28px; height: 28px; font-size: 0.7rem; }
        }

        /* Paysage mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .mobile-header { padding: 5px 10px; min-height: 40px; }
            .chat-header { padding: 8px 12px; }
            .messages-container { padding: 8px; gap: 6px; }
            .input-area { padding: 6px 10px; }
        }

        @media (min-width: 769px) {
            .mobile-header {
                display: none;
            }

            .sidebar-overlay {
                display: none !important;
            }
        }
        /* ===== NOTIFICATIONS ===== */
        .notif-container {
            position: fixed;
            top: 20px;
            top: calc(20px + env(safe-area-inset-top, 0px));
            right: 20px;
            right: calc(20px + env(safe-area-inset-right, 0px));
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 380px;
            pointer-events: none;
        }

        .notif-toast {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 18px;
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 14px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            animation: notifSlideIn 0.4s ease, notifFadeOut 0.4s ease 4.6s forwards;
            pointer-events: auto;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
        }

        .notif-toast:hover {
            transform: scale(1.02);
        }

        .notif-toast.message {
            border-left: 4px solid var(--cyan);
        }

        .notif-toast.contact {
            border-left: 4px solid var(--magenta);
        }

        .notif-toast-icon {
            font-size: 1.8rem;
            flex-shrink: 0;
        }

        .notif-toast-body {
            flex: 1;
            min-width: 0;
        }

        .notif-toast-title {
            font-family: 'Syne', sans-serif;
            font-weight: 700;
            font-size: 0.9rem;
            margin-bottom: 3px;
            color: var(--text);
        }

        .notif-toast-text {
            font-size: 0.8rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .notif-toast-close {
            width: 24px;
            height: 24px;
            border: none;
            background: var(--glass);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notif-toast-close:hover {
            background: var(--red);
            color: white;
        }

        @keyframes notifSlideIn {
            from { opacity: 0; transform: translateX(100px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes notifFadeOut {
            from { opacity: 1; }
            to { opacity: 0; transform: translateY(-10px); }
        }

        /* Badge pulsation pour demandes de contact */
        .tab-btn .badge.pulse {
            animation: badgePulse 1.5s infinite;
        }

        @keyframes badgePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.25); box-shadow: 0 0 12px var(--magenta); }
        }

        /* Indicateur total non lu dans le header mobile */
        .notif-total-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            min-width: 18px;
            height: 18px;
            padding: 0 5px;
            background: var(--magenta);
            border-radius: 10px;
            font-size: 0.65rem;
            font-weight: 700;
            color: white;
            display: none;
            align-items: center;
            justify-content: center;
            border: 2px solid var(--bg-secondary);
        }

        @media (max-width: 768px) {
            .notif-container {
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
            }

            .notif-toast {
                padding: 12px 14px;
            }
        }

        /* Incoming Call Overlay */
        .incoming-call-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .incoming-call-overlay.active {
            display: flex;
        }

        .incoming-call-card {
            text-align: center;
            padding: 40px 50px;
            position: relative;
        }

        .incoming-call-pulse {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -60%);
            width: 120px; height: 120px;
            border-radius: 50%;
            background: rgba(0, 245, 255, 0.15);
            animation: incomingPulse 2s ease-out infinite;
        }

        @keyframes incomingPulse {
            0% { transform: translate(-50%, -60%) scale(0.8); opacity: 1; }
            100% { transform: translate(-50%, -60%) scale(2.5); opacity: 0; }
        }

        .incoming-call-avatar {
            width: 90px; height: 90px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--cyan), var(--magenta));
            display: flex; align-items: center; justify-content: center;
            font-size: 2.2rem; font-weight: 700; color: white;
            margin: 0 auto 20px;
            position: relative;
            z-index: 1;
            box-shadow: 0 0 30px rgba(0, 245, 255, 0.3);
        }

        .incoming-call-name {
            font-family: 'Syne', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 6px;
        }

        .incoming-call-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 35px;
            animation: incomingLabelBlink 1.5s ease-in-out infinite;
        }

        @keyframes incomingLabelBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .incoming-call-actions {
            display: flex;
            gap: 24px;
            justify-content: center;
        }

        .incoming-call-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 16px 28px;
            border: none;
            border-radius: 20px;
            font-family: 'Syne', sans-serif;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
        }

        .incoming-call-btn span {
            font-size: 1.8rem;
        }

        .incoming-call-btn.decline {
            background: rgba(255, 68, 68, 0.2);
            color: var(--red);
            border: 1px solid rgba(255, 68, 68, 0.3);
        }

        .incoming-call-btn.decline:hover {
            background: var(--red);
            color: white;
            transform: scale(1.05);
        }

        .incoming-call-btn.accept {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            border: 1px solid rgba(0, 255, 136, 0.3);
            animation: acceptGlow 1.5s ease-in-out infinite;
        }

        .incoming-call-btn.accept:hover {
            background: #00ff88;
            color: #0a0a0f;
            transform: scale(1.05);
        }

        @keyframes acceptGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 136, 0.2); }
            50% { box-shadow: 0 0 25px rgba(0, 255, 136, 0.4); }
        }

        @media (max-width: 768px) {
            .incoming-call-card {
                padding: 30px 25px;
            }
            .incoming-call-btn {
                padding: 14px 22px;
            }
        }

        /* Voice Messages */
        .voice-btn {
            width: 42px;
            height: 42px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            border: 2px solid var(--glass-border);
            border-radius: 50%;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s;
            flex-shrink: 0;
        }

        .voice-btn:hover {
            border-color: var(--magenta);
            background: rgba(255, 0, 170, 0.1);
        }

        .voice-btn.recording {
            background: rgba(255, 68, 68, 0.2);
            border-color: var(--red);
            animation: voiceRecPulse 1s infinite;
        }

        @keyframes voiceRecPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.4); }
            50% { box-shadow: 0 0 0 8px rgba(255, 68, 68, 0); }
        }

        .voice-recorder-bar {
            display: none;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            background: rgba(255, 68, 68, 0.08);
            border: 1px solid rgba(255, 68, 68, 0.2);
            border-radius: 16px;
            margin-top: 8px;
        }

        .voice-recorder-bar.active {
            display: flex;
        }

        .voice-rec-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--red);
            animation: voiceRecPulse 1s infinite;
            flex-shrink: 0;
        }

        .voice-rec-timer {
            font-family: 'Space Grotesk', monospace;
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--red);
            min-width: 40px;
        }

        .voice-rec-wave {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 2px;
            height: 24px;
            overflow: hidden;
        }

        .voice-rec-wave span {
            display: inline-block;
            width: 3px;
            background: var(--red);
            border-radius: 2px;
            opacity: 0.6;
            transition: height 0.1s;
        }

        .voice-rec-cancel,
        .voice-rec-send {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s;
            flex-shrink: 0;
        }

        .voice-rec-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }

        .voice-rec-cancel:hover {
            background: var(--red);
            color: white;
        }

        .voice-rec-send {
            background: linear-gradient(135deg, var(--magenta), var(--cyan));
            color: white;
        }

        .voice-rec-send:hover {
            transform: scale(1.1);
        }

        /* Voice message player in bubble */
        .voice-msg-player {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 200px;
            padding: 4px 0;
        }

        .voice-msg-play {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, var(--magenta), var(--cyan));
            color: white;
            font-size: 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: transform 0.2s;
        }

        .voice-msg-play:hover {
            transform: scale(1.1);
        }

        .voice-msg-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .voice-msg-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
            overflow: hidden;
            cursor: pointer;
        }

        .voice-msg-progress {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--magenta), var(--cyan));
            border-radius: 2px;
            transition: width 0.1s linear;
        }

        .voice-msg-duration {
            font-size: 0.7rem;
            color: var(--text-secondary);
            font-family: 'Space Grotesk', monospace;
        }

        .message.own .voice-msg-play {
            background: linear-gradient(135deg, var(--cyan), var(--magenta));
        }

        @media (max-width: 768px) {
            .voice-msg-player { min-width: 160px; }
            .voice-msg-play { width: 32px; height: 32px; font-size: 0.9rem; }
        }

        /* Video Call */
        .vc-rec{display:inline-block;width:12px;height:12px;background:var(--red);border-radius:50%;animation:vcPulse 1s infinite}
        @keyframes vcPulse{0%,100%{opacity:1}50%{opacity:0.3}}
        #modalVideoCall{padding:0}
        #modalVideoCall .modal{display:flex;flex-direction:column}
        #vcVideoGrid{display:flex;flex-wrap:wrap;gap:8px;justify-content:center;padding:8px}
        .vc-cell{position:relative;background:#222;border-radius:12px;overflow:hidden;flex:1 1 45%;max-width:48%;aspect-ratio:16/9;min-width:280px}
        .vc-cell.local{border:2px solid var(--cyan)}
        .vc-cell video{width:100%;height:100%;object-fit:cover;display:block}
        .vc-cell .vc-nametag{position:absolute;bottom:8px;left:8px;padding:4px 10px;background:rgba(0,0,0,0.7);border-radius:8px;font-size:0.75rem;color:#fff;z-index:2}
        #vcControls .icon-btn{width:56px;height:56px;font-size:1.4rem;border-radius:50%}
        #vcControls .icon-btn.off{background:var(--red);color:white}
        @media(min-width:769px){
            #vcVideoGrid:has(.vc-cell:nth-child(3)) .vc-cell{flex:1 1 30%;max-width:32%}
        }
        @media(max-width:768px){
            #modalVideoCall .modal-overlay.active,#modalVideoCall .modal{border-radius:0}
            .vc-cell{flex:1 1 100%;max-width:100%;min-width:0;aspect-ratio:4/3}
            #vcVideoGrid{gap:6px;padding:6px}
            #vcControls .icon-btn{width:52px;height:52px;font-size:1.3rem}
        }
    </style>
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Organization",
      "name": "TLD",
      "url": "https://tino-le-doc.com",
      "logo": "https://tino-le-doc.com/img/1000074494.png"
    }
    </script>
</head>
<body>
    <a href="appareils-connectes.html" class="tino-iot-banner" aria-label="Tino Assistant IoT">
        <span class="tino-iot-banner-icon">ðŸ“¡</span>
        <span class="tino-iot-banner-text">
            <span class="tino-iot-banner-title">Tino Assistant IoT</span>
            <span class="tino-iot-banner-sub">Appareils connectes &amp; IA</span>
        </span>
        <span class="tino-iot-banner-dot"></span>
    </a>
    <a href="#main-content" class="skip-link">Aller au contenu</a>
    <nav class="nav-dropdown" aria-label="Navigation rapide">
        <select onchange="if(this.value) window.location.href=this.value" aria-label="Naviguer vers une page">
            <option value="">&#9776; Menu</option>
            <option value="index.html">&#127968; Accueil</option>
            <option value="veille-techno.html">&#128225; Veille Techno</option>
            <option value="quiz.html">&#129504; Quiz</option>
            <option value="sondages.html">&#128202; Sondages</option>
            <option value="debat.html">&#9876;&#65039; D&eacute;bat</option>
            <option value="tchat.html">&#128172; Tchat</option>
            <option value="messagerie.html" selected>&#9993;&#65039; Messagerie</option>
            <option value="forum.html">&#127963;&#65039; Forum</option>
            <option value="avis.html">&#11088; Avis</option>
            <option value="compte.html">&#128100; Compte</option>
            <option value="premium.html">&#128081; Premium</option>
            <option value="boutique.html">&#128722; Boutique</option>
            <option value="appareils-connectes.html">&#128225; Appareils IA</option>
            <option value="contact.html">&#128231; Contact</option>
            <option value="confidentialite.html">&#128274; Confidentialit&eacute;</option>
        </select>
    </nav>

    <!-- Notification Toasts -->
    <div class="notif-container" id="notifContainer"></div>

    <!-- Login Required Screen -->
    <div class="login-required" id="loginRequired">
        <div class="icon">ðŸ”</div>
        <h1>Connexion requise</h1>
        <p>Connectez-vous ou crÃ©ez un compte pour accÃ©der Ã  la messagerie privÃ©e, ajouter des contacts et crÃ©er des groupes.</p>
        <a href="compte.html" class="btn btn-primary">ðŸ‘¤ Se connecter / S'inscrire</a>
        <br><br>
        <a href="tchat.html" style="color: var(--cyan);">ðŸ’¬ Ou accÃ©der au tchat public</a>
    </div>

    <!-- Main App -->
    <div class="app-container" id="main-content" style="display: none;">
        <!-- Overlay sidebar mobile -->
        <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeSidebar()"></div>

        <!-- Mobile Header -->
        <div class="mobile-header">
            <button class="icon-btn" onclick="toggleSidebar()" style="position:relative;">â˜°<span class="notif-total-badge" id="mobileUnreadBadge">0</span></button>
            <span>Messagerie</span>
        </div>

        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h1>ðŸ’¬ Messagerie</h1>
                <div class="header-actions">
                    <button class="icon-btn" onclick="openModal('newGroup')" title="Nouveau groupe">ðŸ‘¥</button>
                    <button class="icon-btn" onclick="openModal('addContact')" title="Ajouter contact">âž•</button>
                    <a href="index.html" class="icon-btn" title="Retour">ðŸ </a>
                </div>
            </div>

            <div class="sidebar-tabs">
                <button class="tab-btn active" data-tab="conversations">ðŸ’¬ Conversations</button>
                <button class="tab-btn" data-tab="contacts">ðŸ‘¥ Contacts <span class="badge" id="requestsBadge" style="display:none;">0</span></button>
            </div>

            <div class="search-box">
                <input type="text" class="search-input" id="searchInput" placeholder="ðŸ” Rechercher...">
            </div>

            <!-- Conversations Tab -->
            <div class="conversations-list" id="conversationsTab">
                <div id="conversationsList">
                    <!-- Filled by JS -->
                </div>

                <div class="empty-state" id="emptyConversations" style="display: none;">
                    <div class="icon">ðŸ’¬</div>
                    <h3>Aucune conversation</h3>
                    <p>Ajoutez des contacts ou crÃ©ez un groupe pour commencer</p>
                </div>
            </div>

            <!-- Contacts Tab -->
            <div class="conversations-list" id="contactsTab" style="display: none;">
                <!-- Friend Requests -->
                <div id="friendRequests"></div>

                <!-- Contacts List -->
                <div id="contactsList">
                    <div class="empty-state">
                        <div class="icon">ðŸ‘¥</div>
                        <h3>Aucun contact</h3>
                        <p>Recherchez des utilisateurs pour les ajouter</p>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Chat Area -->
        <main class="chat-area" id="chatArea">
            <!-- No chat selected -->
            <div class="no-chat" id="noChat">
                <div class="icon">ðŸ’¬</div>
                <h2>Bienvenue !</h2>
                <p>SÃ©lectionnez une conversation ou crÃ©ez-en une nouvelle pour commencer Ã  discuter.</p>
            </div>

            <!-- Active Chat -->
            <div id="activeChat" style="display: none;">
                <div class="chat-header">
                    <button class="icon-btn" onclick="toggleSidebar()" style="display: none;" id="mobileBackBtn">â†</button>
                    <div class="conv-avatar" id="chatAvatar">?</div>
                    <div class="chat-header-info">
                        <div class="chat-header-name" id="chatName">Chat</div>
                        <div class="chat-header-status" id="chatStatus">-</div>
                    </div>
                    <div class="chat-header-actions">
                        <button class="icon-btn" id="videoCallBtn" onclick="startVideoCall()" style="display:none;" title="Appel vidÃ©o">ðŸ“¹</button>
                        <button class="icon-btn" id="chatInfoBtn" onclick="openChatInfo()">â„¹ï¸</button>
                    </div>
                </div>

                <div class="messages-container" id="messagesContainer">
                    <!-- Messages filled by JS -->
                </div>

                <div class="input-area" style="position:relative;">
                    <div class="emoji-picker" id="emojiPicker">
                        <div class="emoji-categories" id="emojiCategories"></div>
                        <div class="emoji-grid" id="emojiGrid"></div>
                    </div>
                    <form class="input-form" id="messageForm">
                        <button type="button" class="emoji-btn" id="emojiToggle" title="Emojis">ðŸ˜Š</button>
                        <input type="text" id="messageInput" placeholder="Ã‰crire un message..." maxlength="500" autocomplete="off">
                        <button type="button" class="voice-btn" id="voiceRecordBtn" onclick="VoiceRecorder.toggle()" title="Message vocal">ðŸŽ™ï¸</button>
                        <button type="submit">ðŸ“¤</button>
                    </form>
                    <div class="voice-recorder-bar" id="voiceRecorderBar">
                        <div class="voice-rec-indicator"></div>
                        <span class="voice-rec-timer" id="voiceRecTimer">0:00</span>
                        <div class="voice-rec-wave" id="voiceRecWave"></div>
                        <button type="button" class="voice-rec-cancel" onclick="VoiceRecorder.cancel()" title="Annuler">âœ•</button>
                        <button type="button" class="voice-rec-send" onclick="VoiceRecorder.stopAndSend()" title="Envoyer">ðŸ“¤</button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Modal: Add Contact -->
    <div class="modal-overlay" id="modalAddContact">
        <div class="modal">
            <div class="modal-header">
                <h2>âž• Ajouter un contact</h2>
                <button class="modal-close" onclick="closeModal('addContact')">âœ•</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Rechercher par pseudo</label>
                    <input type="text" id="searchUserInput" placeholder="Entrez un pseudo..." maxlength="20">
                </div>
                <div id="searchResults"></div>
            </div>
        </div>
    </div>

    <!-- Modal: New Group -->
    <div class="modal-overlay" id="modalNewGroup">
        <div class="modal">
            <div class="modal-header">
                <h2>ðŸ‘¥ CrÃ©er un groupe</h2>
                <button class="modal-close" onclick="closeModal('newGroup')">âœ•</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Nom du groupe</label>
                    <input type="text" id="groupName" placeholder="Ex: Mes amis..." maxlength="30">
                </div>
                <div class="form-group">
                    <label>Description (optionnel)</label>
                    <textarea id="groupDescription" placeholder="De quoi parle ce groupe ?" maxlength="100"></textarea>
                </div>
                <div class="members-section">
                    <h4>Membres sÃ©lectionnÃ©s</h4>
                    <div id="selectedMembers">
                        <p style="color: var(--text-secondary); font-size: 0.85rem;">SÃ©lectionnez des contacts ci-dessous</p>
                    </div>
                </div>
                <div class="form-group">
                    <label>Ajouter des contacts</label>
                    <div id="contactsForGroup"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('newGroup')">Annuler</button>
                <button class="btn btn-primary" onclick="createGroup()">CrÃ©er le groupe</button>
            </div>
        </div>
    </div>

    <!-- Modal: Chat Info -->
    <div class="modal-overlay" id="modalChatInfo">
        <div class="modal">
            <div class="modal-header">
                <h2>â„¹ï¸ Informations</h2>
                <button class="modal-close" onclick="closeModal('chatInfo')">âœ•</button>
            </div>
            <div class="modal-body" id="chatInfoContent">
                <!-- Filled by JS -->
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="leaveGroupBtn" onclick="leaveGroup()" style="display: none;">ðŸšª Quitter le groupe</button>
            </div>
        </div>
    </div>

    <!-- Modal: Video Call -->
    <div class="modal-overlay" id="modalVideoCall" style="background:rgba(0,0,0,0.95);">
        <div class="modal" style="max-width:100%;width:100%;max-height:100vh;max-height:100dvh;height:100vh;height:100dvh;background:#0a0a0f;border-radius:0;border:none;">
            <div class="modal-header" style="background:linear-gradient(135deg,rgba(255,68,68,0.2),rgba(255,149,0,0.2));padding:12px 20px;flex-shrink:0;">
                <h2><span class="vc-rec"></span> Appel vidÃ©o - <span id="vcCallName">...</span></h2>
                <div style="display:flex;align-items:center;gap:10px;">
                    <span id="vcParticipantCount" style="font-size:0.8rem;color:rgba(255,255,255,0.6);">0 en appel</span>
                    <button class="modal-close" onclick="DMVideoChat.leaveCall()">âœ•</button>
                </div>
            </div>
            <div class="modal-body" style="padding:0;max-height:none;overflow:hidden;flex:1;display:flex;flex-direction:column;">
                <!-- Ecran de jointure -->
                <div id="vcJoinScreen" style="padding:40px 20px;text-align:center;flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;">
                    <div style="font-size:4rem;margin-bottom:20px;">ðŸ“¹</div>
                    <h3 style="font-family:'Syne',sans-serif;font-size:1.3rem;margin-bottom:10px;">Appel vidÃ©o</h3>
                    <p style="color:rgba(255,255,255,0.6);margin-bottom:20px;">DÃ©marrez un appel vidÃ©o en direct</p>
                    <button id="vcJoinBtn" onclick="DMVideoChat.joinCall()" style="padding:15px 35px;border:none;border-radius:15px;font-family:'Syne',sans-serif;font-size:1.1rem;font-weight:700;cursor:pointer;background:linear-gradient(135deg,#00ff88,#00cc6a);color:#0a0a0f;transition:all 0.3s;">ðŸ“¹ Rejoindre l'appel</button>
                </div>
                <!-- Grille vidÃ©o -->
                <div id="vcVideoGrid" style="display:none;padding:10px;background:#000;flex:1;align-content:center;"></div>
                <!-- Controles -->
                <div id="vcControls" style="display:none;padding:15px;background:rgba(0,0,0,0.8);justify-content:center;gap:12px;align-items:center;flex-shrink:0;">
                    <button class="icon-btn" id="vcMicBtn" onclick="DMVideoChat.toggleMic()" title="Micro">ðŸŽ¤</button>
                    <button class="icon-btn" id="vcCamBtn" onclick="DMVideoChat.toggleCam()" title="CamÃ©ra">ðŸ“¹</button>
                    <button class="icon-btn danger" id="vcLeaveBtn" onclick="DMVideoChat.leaveCall()" title="Raccrocher" style="background:var(--red);color:white;">ðŸ“ž</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Overlay: Appel entrant -->
    <div class="incoming-call-overlay" id="incomingCallOverlay">
        <div class="incoming-call-card">
            <div class="incoming-call-pulse"></div>
            <div class="incoming-call-avatar" id="incomingCallAvatar">?</div>
            <div class="incoming-call-name" id="incomingCallName">Appel entrant...</div>
            <div class="incoming-call-label">Appel vidÃ©o entrant</div>
            <div class="incoming-call-actions">
                <button class="incoming-call-btn decline" id="incomingDeclineBtn" onclick="IncomingCallSystem.decline()">
                    <span>ðŸ“ž</span>
                    Refuser
                </button>
                <button class="incoming-call-btn accept" id="incomingAcceptBtn" onclick="IncomingCallSystem.accept()">
                    <span>ðŸ“¹</span>
                    Accepter
                </button>
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-analytics-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>
    <script src="js/firebase-config.js"></script>
    <script>
        // Config Firebase chargee depuis js/firebase-config.js
        const auth = firebaseAuth;
        const db = firebaseDb;

        // ==================== STATE ====================
        let currentUser = null;
        let currentUserProfile = null;
        let currentChat = null;
        let currentChatType = null;
        let contacts = {};
        let conversations = {};
        let selectedGroupMembers = [];
        let messageListeners = {};

        // ==================== AUTH STATE ====================
        auth.onAuthStateChanged(async user => {
            if (user) {
                currentUser = user;
                try {
                    const snapshot = await db.ref('users/' + user.uid).once('value');
                    currentUserProfile = snapshot.val();
                    
                    if (currentUserProfile && currentUserProfile.pseudo) {
                        document.getElementById('loginRequired').style.display = 'none';
                        document.getElementById('main-content').style.display = 'flex';
                        initApp();
                    } else {
                        // Profil incomplet ou inexistant, rediriger vers la page compte
                        window.location.href = 'compte.html';
                    }
                } catch (e) {
                    console.error('Erreur profil:', e);
                    window.location.href = 'compte.html';
                }
            } else {
                document.getElementById('loginRequired').style.display = 'flex';
                document.getElementById('main-content').style.display = 'none';
            }
        });

        // ==================== INIT APP ====================
        function initApp() {
            loadContacts();
            loadFriendRequests();
            loadConversations();
            setupTabs();
            setupSearch();

            // Message form
            document.getElementById('messageForm').addEventListener('submit', e => {
                e.preventDefault();
                sendMessage();
            });

            // Fix clavier Android : garder l'input visible
            const msgInputEl = document.getElementById('messageInput');
            if (msgInputEl) {
                msgInputEl.addEventListener('focus', () => {
                    setTimeout(() => {
                        msgInputEl.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                    }, 300);
                });
            }

            // Gestion du resize par le clavier virtuel
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', () => {
                    document.documentElement.style.height = window.visualViewport.height + 'px';
                });
                window.visualViewport.addEventListener('scroll', () => {
                    document.documentElement.style.height = window.visualViewport.height + 'px';
                });
            }

            // Search user
            document.getElementById('searchUserInput').addEventListener('input', debounce(searchUsers, 500));

            console.log('âœ… Messagerie initialisÃ©e pour:', currentUserProfile.pseudo);
        }

        // ==================== TABS ====================
        function setupTabs() {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');

                    const tab = this.dataset.tab;
                    document.getElementById('conversationsTab').style.display = tab === 'conversations' ? 'block' : 'none';
                    document.getElementById('contactsTab').style.display = tab === 'contacts' ? 'block' : 'none';
                });
            });
        }

        // ==================== SEARCH ====================
        function setupSearch() {
            document.getElementById('searchInput').addEventListener('input', function() {
                const query = this.value.toLowerCase();
                const isContactsTab = document.getElementById('contactsTab').style.display !== 'none';

                if (isContactsTab) {
                    // Filtrer les contacts
                    document.querySelectorAll('#contactsList .user-item').forEach(item => {
                        const name = item.querySelector('.user-item-name')?.textContent.toLowerCase() || '';
                        item.style.display = name.includes(query) ? 'flex' : 'none';
                    });
                    // Filtrer aussi les demandes d'amis
                    document.querySelectorAll('#friendRequests .user-item').forEach(item => {
                        const name = item.querySelector('.user-item-name')?.textContent.toLowerCase() || '';
                        item.style.display = name.includes(query) ? 'flex' : 'none';
                    });
                } else {
                    document.querySelectorAll('.conv-item').forEach(item => {
                        const name = item.querySelector('.conv-name')?.textContent.toLowerCase() || '';
                        item.style.display = name.includes(query) ? 'flex' : 'none';
                    });
                }
            });
        }

        // ==================== CONTACTS ====================
        function loadContacts() {
            db.ref('contacts/' + currentUser.uid).on('value', async snapshot => {
                contacts = {};
                const contactsDiv = document.getElementById('contactsList');
                const groupContactsDiv = document.getElementById('contactsForGroup');

                if (!snapshot.exists()) {
                    contactsDiv.innerHTML = `
                        <div class="empty-state">
                            <div class="icon">ðŸ‘¥</div>
                            <h3>Aucun contact</h3>
                            <p>Recherchez des utilisateurs pour les ajouter</p>
                        </div>
                    `;
                    groupContactsDiv.innerHTML = '<p style="color: var(--text-secondary);">Aucun contact</p>';
                    return;
                }

                let contactsHTML = '';
                let groupHTML = '';

                for (const [oderId, data] of Object.entries(snapshot.val())) {
                    // Le pseudo est stockÃ© dans le contact (pas besoin de lire users/)
                    const pseudo = data.pseudo || 'Utilisateur';
                    contacts[oderId] = { pseudo, oderId };

                    contactsHTML += `
                        <div class="user-item">
                            <div class="user-item-avatar">${pseudo.charAt(0).toUpperCase()}</div>
                            <div class="user-item-info">
                                <div class="user-item-name">${escapeHtml(pseudo)}</div>
                                <div class="user-item-status">Contact</div>
                            </div>
                            <div class="user-item-actions">
                                <button class="message" onclick="startDM('${oderId}')">ðŸ’¬</button>
                            </div>
                        </div>
                    `;

                    groupHTML += `
                        <div class="user-item" data-uid="${oderId}" data-pseudo="${escapeHtml(pseudo)}" onclick="toggleGroupMember(this.dataset.uid, this.dataset.pseudo)" style="cursor:pointer;">
                            <div class="user-item-avatar">${pseudo.charAt(0).toUpperCase()}</div>
                            <div class="user-item-info">
                                <div class="user-item-name">${escapeHtml(pseudo)}</div>
                            </div>
                            <input type="checkbox" id="check_${oderId}">
                        </div>
                    `;
                }

                contactsDiv.innerHTML = contactsHTML || '<p style="color: var(--text-secondary); padding: 20px;">Aucun contact</p>';
                groupContactsDiv.innerHTML = groupHTML || '<p style="color: var(--text-secondary);">Aucun contact</p>';
            });
        }

        // ==================== FRIEND REQUESTS ====================
        function loadFriendRequests() {
            db.ref('friendRequests/' + currentUser.uid).on('value', async snapshot => {
                const requestsDiv = document.getElementById('friendRequests');
                const badge = document.getElementById('requestsBadge');

                if (!snapshot.exists()) {
                    requestsDiv.innerHTML = '';
                    badge.style.display = 'none';
                    return;
                }

                const requests = snapshot.val();
                let manualCount = 0;

                let html = '';

                for (const [oderId, data] of Object.entries(requests)) {
                    // Auto-accept : l'autre a dÃ©jÃ  acceptÃ©, on s'ajoute mutuellement
                    if (data.autoAccept) {
                        await db.ref('contacts/' + currentUser.uid + '/' + oderId).set({
                            pseudo: data.pseudo || 'Utilisateur',
                            addedAt: Date.now()
                        });
                        await db.ref('friendRequests/' + currentUser.uid + '/' + oderId).remove();
                        continue;
                    }

                    manualCount++;
                    const pseudo = data.pseudo || 'Utilisateur';
                    html += `
                        <div class="user-item" data-uid="${oderId}" data-pseudo="${escapeHtml(pseudo)}">
                            <div class="user-item-avatar">${pseudo.charAt(0).toUpperCase()}</div>
                            <div class="user-item-info">
                                <div class="user-item-name">${escapeHtml(pseudo)}</div>
                                <div class="user-item-status">Veut vous ajouter</div>
                            </div>
                            <div class="user-item-actions">
                                <button class="accept" onclick="acceptFriendRequest(this.closest('.user-item').dataset.uid, this.closest('.user-item').dataset.pseudo)">âœ“</button>
                                <button class="reject" onclick="rejectFriendRequest('${oderId}')">âœ•</button>
                            </div>
                        </div>
                    `;
                }

                badge.textContent = manualCount;
                badge.style.display = manualCount > 0 ? 'inline-flex' : 'none';

                if (html) {
                    html = '<h4 style="padding: 10px; color: var(--magenta);">ðŸ“¨ Demandes d\'amis</h4>' + html;
                }
                requestsDiv.innerHTML = html;
            });
        }

        async function sendFriendRequest(oderId) {
            if (oderId === currentUser.uid) {
                alert('Vous ne pouvez pas vous ajouter vous-mÃªme !');
                return;
            }

            try {
                // VÃ©rifie si dÃ©jÃ  en contact (lecture autorisÃ©e : c'est notre propre noeud)
                const contactSnap = await db.ref('contacts/' + currentUser.uid + '/' + oderId).once('value');
                if (contactSnap.exists()) {
                    alert('DÃ©jÃ  dans vos contacts !');
                    return;
                }

                // Envoie la demande avec le pseudo (Ã©vite de lire users/ cÃ´tÃ© destinataire)
                await db.ref('friendRequests/' + oderId + '/' + currentUser.uid).set({
                    from: currentUser.uid,
                    pseudo: currentUserProfile.pseudo,
                    timestamp: Date.now()
                });

                alert('Demande envoyÃ©e ! âœ…');

                // Email notification au destinataire
                EmailNotifier.notifyContactRequest(oderId, currentUserProfile.pseudo);
            } catch (err) {
                console.error('Erreur envoi demande:', err);
                alert('Erreur lors de l\'envoi de la demande.');
            }
        }

        async function acceptFriendRequest(oderId, pseudo) {
            try {
                // Ajouter Ã  MES contacts (autorisÃ© : auth.uid == $oderId)
                await db.ref('contacts/' + currentUser.uid + '/' + oderId).set({
                    pseudo: pseudo || 'Utilisateur',
                    addedAt: Date.now()
                });

                // Envoyer une demande inverse pour que l'autre nous ajoute automatiquement
                // (on ne peut pas Ã©crire dans contacts/{autreUid}, mais on peut Ã©crire dans friendRequests/{autreUid})
                await db.ref('friendRequests/' + oderId + '/' + currentUser.uid).set({
                    from: currentUser.uid,
                    pseudo: currentUserProfile.pseudo,
                    timestamp: Date.now(),
                    autoAccept: true
                });

                // Supprimer la demande reÃ§ue
                await db.ref('friendRequests/' + currentUser.uid + '/' + oderId).remove();
            } catch (err) {
                console.error('Erreur acceptation:', err);
            }
        }

        async function rejectFriendRequest(oderId) {
            await db.ref('friendRequests/' + currentUser.uid + '/' + oderId).remove();
        }

        // ==================== SEARCH USERS ====================
        async function searchUsers() {
            const query = document.getElementById('searchUserInput').value.trim().toLowerCase();
            const resultsDiv = document.getElementById('searchResults');

            if (query.length < 2) {
                resultsDiv.innerHTML = '<p style="color: var(--text-secondary); text-align: center;">Entrez au moins 2 caractÃ¨res</p>';
                return;
            }

            resultsDiv.innerHTML = '<p style="color: var(--text-secondary); text-align: center;">Recherche...</p>';

            try {
                // RequÃªte par prÃ©fixe sur le noeud "pseudos" (lecture publique)
                // Les pseudos sont stockÃ©s en minuscules comme clÃ©s
                const snapshot = await db.ref('pseudos')
                    .orderByKey()
                    .startAt(query)
                    .endAt(query + '\uf8ff')
                    .limitToFirst(11)
                    .once('value');

                if (!snapshot.exists()) {
                    resultsDiv.innerHTML = '<p style="color: var(--text-secondary); text-align: center;">Aucun utilisateur trouvÃ©</p>';
                    return;
                }

                const users = [];
                snapshot.forEach(child => {
                    if (users.length >= 10) return;
                    const uid = child.val();
                    const pseudoKey = child.key;
                    if (uid !== currentUser.uid) {
                        users.push({ uid, pseudo: pseudoKey });
                    }
                });

                if (users.length === 0) {
                    resultsDiv.innerHTML = '<p style="color: var(--text-secondary); text-align: center;">Aucun rÃ©sultat</p>';
                    return;
                }

                // Afficher les rÃ©sultats depuis les clÃ©s du noeud pseudos
                let html = '';
                for (const { uid, pseudo } of users) {
                    const displayPseudo = pseudo || 'Utilisateur';
                    const isAlreadyContact = contacts && contacts[uid];
                    html += `
                        <div class="user-item">
                            <div class="user-item-avatar">${displayPseudo.charAt(0).toUpperCase()}</div>
                            <div class="user-item-info">
                                <div class="user-item-name">${escapeHtml(displayPseudo)}</div>
                                ${isAlreadyContact ? '<div class="user-item-status">DÃ©jÃ  en contact</div>' : ''}
                            </div>
                            <div class="user-item-actions">
                                ${isAlreadyContact
                                    ? '<button class="message" onclick="startDM(\'' + uid + '\')">ðŸ’¬</button>'
                                    : '<button class="add" onclick="sendFriendRequest(\'' + uid + '\')">âž• Ajouter</button>'
                                }
                            </div>
                        </div>
                    `;
                }

                resultsDiv.innerHTML = html || '<p style="color: var(--text-secondary); text-align: center;">Aucun rÃ©sultat</p>';
            } catch (err) {
                console.error('Erreur recherche:', err);
                resultsDiv.innerHTML = '<p style="color: var(--text-secondary); text-align: center;">Erreur lors de la recherche</p>';
            }
        }

        // ==================== CONVERSATIONS ====================
        function loadConversations() {
            // Load DMs
            db.ref('userConversations/' + currentUser.uid).on('value', async snapshot => {
                const listDiv = document.getElementById('conversationsList');

                if (!snapshot.exists()) {
                    updateConversationsUI();
                    return;
                }

                conversations = {};
                let html = '';

                for (const [convId, data] of Object.entries(snapshot.val())) {
                    conversations[convId] = data;

                    if (data.type === 'dm') {
                        const otherUserId = data.participants ? data.participants.find(p => p !== currentUser.uid) : null;
                        const otherPseudo = data.otherPseudo || (otherUserId && contacts[otherUserId] && contacts[otherUserId].pseudo) || 'Utilisateur';
                        html += createConvItem(convId, 'dm', otherPseudo, data.lastMessage, data.lastTime, data.unread);
                    } else if (data.type === 'group') {
                        html += createConvItem(convId, 'group', data.name, data.lastMessage, data.lastTime, data.unread);
                    }
                }

                listDiv.innerHTML = html;
                updateConversationsUI();
            });
        }

        function createConvItem(id, type, name, lastMsg, lastTime, unread) {
            const avatarClass = type === 'dm' ? 'user' : 'group';
            const icon = type === 'group' ? '<span class="group-icon">ðŸ‘¥</span>' : '';
            const initial = name.charAt(0).toUpperCase();
            const time = lastTime ? formatTime(lastTime) : '';
            const preview = lastMsg ? escapeHtml(lastMsg.substring(0, 30)) + (lastMsg.length > 30 ? '...' : '') : 'Aucun message';
            const unreadBadge = unread > 0 ? `<div class="conv-unread">${unread}</div>` : '';
            const unreadClass = unread > 0 ? 'unread' : '';

            return `
                <div class="conv-item ${unreadClass}" data-type="${type}" data-id="${id}" onclick="openChat('${type}', '${id}')">
                    <div class="conv-avatar ${avatarClass}">${initial}</div>
                    <div class="conv-info">
                        <div class="conv-name">${icon}${escapeHtml(name)}</div>
                        <div class="conv-preview">${preview}</div>
                    </div>
                    <div class="conv-meta">
                        <div class="conv-time">${time}</div>
                        ${unreadBadge}
                    </div>
                </div>
            `;
        }

        function updateConversationsUI() {
            const list = document.getElementById('conversationsList');
            const empty = document.getElementById('emptyConversations');
            empty.style.display = list.children.length === 0 ? 'block' : 'none';
        }

        // ==================== GROUPS ====================
        function toggleGroupMember(oderId, pseudo) {
            const checkbox = document.getElementById('check_' + oderId);
            const idx = selectedGroupMembers.findIndex(m => m.oderId === oderId);

            if (idx > -1) {
                selectedGroupMembers.splice(idx, 1);
                checkbox.checked = false;
            } else {
                selectedGroupMembers.push({ oderId, pseudo });
                checkbox.checked = true;
            }

            updateSelectedMembers();
        }

        function updateSelectedMembers() {
            const div = document.getElementById('selectedMembers');

            if (selectedGroupMembers.length === 0) {
                div.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.85rem;">SÃ©lectionnez des contacts ci-dessous</p>';
                return;
            }

            div.innerHTML = selectedGroupMembers.map(m => `
                <span class="member-chip">
                    ${escapeHtml(m.pseudo)}
                    <button class="remove" onclick="removeGroupMember('${m.oderId}')">âœ•</button>
                </span>
            `).join('');
        }

        function removeGroupMember(oderId) {
            const idx = selectedGroupMembers.findIndex(m => m.oderId === oderId);
            if (idx > -1) {
                selectedGroupMembers.splice(idx, 1);
                const checkbox = document.getElementById('check_' + oderId);
                if (checkbox) checkbox.checked = false;
                updateSelectedMembers();
            }
        }

        async function createGroup() {
            const name = document.getElementById('groupName').value.trim();
            const description = document.getElementById('groupDescription').value.trim();

            if (!name || name.length < 2) {
                alert('Le nom du groupe doit faire au moins 2 caractÃ¨res');
                return;
            }

            if (selectedGroupMembers.length === 0) {
                alert('Ajoutez au moins un membre au groupe');
                return;
            }

            // Create group
            const groupRef = db.ref('groups').push();
            const groupId = groupRef.key;

            const members = {
                [currentUser.uid]: { role: 'admin', joinedAt: Date.now() }
            };

            selectedGroupMembers.forEach(m => {
                members[m.oderId] = { role: 'member', joinedAt: Date.now() };
            });

            await groupRef.set({
                name,
                description,
                createdBy: currentUser.uid,
                createdAt: Date.now(),
                members
            });

            // Add to all members' conversations
            const allMembers = [currentUser.uid, ...selectedGroupMembers.map(m => m.oderId)];

            for (const oderId of allMembers) {
                await db.ref('userConversations/' + oderId + '/' + groupId).set({
                    type: 'group',
                    name,
                    lastMessage: 'Groupe crÃ©Ã©',
                    lastTime: Date.now(),
                    unread: oderId === currentUser.uid ? 0 : 1
                });
            }

            // System message
            await db.ref('groupMessages/' + groupId).push({
                type: 'system',
                text: `${currentUserProfile.pseudo} a crÃ©Ã© le groupe`,
                timestamp: Date.now()
            });

            // Reset and close
            selectedGroupMembers = [];
            document.getElementById('groupName').value = '';
            document.getElementById('groupDescription').value = '';
            closeModal('newGroup');

            alert('Groupe crÃ©Ã© ! âœ…');
        }

        // ==================== DM ====================
        async function startDM(otherUserId) {
            try {
                const convId = [currentUser.uid, otherUserId].sort().join('_');
                const existingConv = await db.ref('userConversations/' + currentUser.uid + '/' + convId).once('value');

                if (!existingConv.exists()) {
                    // Pseudo depuis les contacts locaux (pas de lecture users/)
                    const otherPseudo = (contacts[otherUserId] && contacts[otherUserId].pseudo) || 'Utilisateur';

                    await db.ref('userConversations/' + currentUser.uid + '/' + convId).set({
                        type: 'dm',
                        otherPseudo: otherPseudo,
                        participants: [currentUser.uid, otherUserId],
                        lastMessage: '',
                        lastTime: Date.now(),
                        unread: 0
                    });

                    await db.ref('userConversations/' + otherUserId + '/' + convId).set({
                        type: 'dm',
                        otherPseudo: currentUserProfile.pseudo,
                        participants: [currentUser.uid, otherUserId],
                        lastMessage: '',
                        lastTime: Date.now(),
                        unread: 0
                    });
                }

                openChat('dm', convId);
                closeModal('addContact');
            } catch (err) {
                console.error('Erreur startDM:', err);
            }
        }

        // ==================== OPEN CHAT ====================
        async function openChat(type, id) {
            // Clear previous listener
            if (messageListeners[currentChat]) {
                db.ref(messageListeners[currentChat].path).off('child_added', messageListeners[currentChat].callback);
            }

            currentChatType = type;
            currentChat = id;

            document.getElementById('noChat').style.display = 'none';
            document.getElementById('activeChat').style.display = 'flex';
            document.getElementById('activeChat').style.flexDirection = 'column';

            const messagesContainer = document.getElementById('messagesContainer');
            messagesContainer.innerHTML = '';

            // Update header based on type
            const avatar = document.getElementById('chatAvatar');
            const nameEl = document.getElementById('chatName');
            const statusEl = document.getElementById('chatStatus');

            if (type === 'dm') {
                const conv = conversations[id];
                if (conv) {
                    // Pseudo stockÃ© dans la conversation ou depuis les contacts locaux
                    const otherUserId = conv.participants ? conv.participants.find(p => p !== currentUser.uid) : null;
                    const otherPseudo = conv.otherPseudo || (otherUserId && contacts[otherUserId] && contacts[otherUserId].pseudo) || 'Utilisateur';

                    avatar.className = 'conv-avatar user';
                    avatar.textContent = otherPseudo.charAt(0).toUpperCase();
                    nameEl.textContent = otherPseudo;
                    statusEl.textContent = 'Message privÃ©';
                    statusEl.className = 'chat-header-status';
                }
                document.getElementById('leaveGroupBtn').style.display = 'none';
                document.getElementById('videoCallBtn').style.display = 'flex';

                loadMessages('dmMessages/' + id);
            } else if (type === 'group') {
                const conv = conversations[id];
                if (conv) {
                    avatar.className = 'conv-avatar group';
                    avatar.textContent = conv.name.charAt(0).toUpperCase();
                    nameEl.textContent = conv.name;

                    const groupSnap = await db.ref('groups/' + id + '/members').once('value');
                    const memberCount = groupSnap.exists() ? Object.keys(groupSnap.val()).length : 0;
                    statusEl.textContent = `${memberCount} membres`;
                    statusEl.className = 'chat-header-status';
                }
                document.getElementById('leaveGroupBtn').style.display = 'block';
                document.getElementById('videoCallBtn').style.display = 'flex';

                loadMessages('groupMessages/' + id);
            }

            // Mark as read
            if (type !== 'public') {
                await db.ref('userConversations/' + currentUser.uid + '/' + id + '/unread').set(0);
            }

            // Update active state in sidebar
            document.querySelectorAll('.conv-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.id === id) item.classList.add('active');
            });

            // Mobile: close sidebar
            closeSidebar();
        }

        // ==================== MESSAGES ====================
        function loadMessages(path) {
            const container = document.getElementById('messagesContainer');

            const callback = snapshot => {
                const msg = snapshot.val();
                if (msg) displayMessage(msg);
            };

            db.ref(path).orderByChild('timestamp').limitToLast(100).on('child_added', callback);

            messageListeners[currentChat] = { path, callback };
        }

        function displayMessage(msg) {
            const container = document.getElementById('messagesContainer');
            const div = document.createElement('div');

            if (msg.type === 'system') {
                div.className = 'message-system ' + (msg.action || '');
                div.textContent = msg.text || `${msg.user} ${msg.action === 'join' ? 'a rejoint' : 'a quittÃ©'}`;
            } else {
                const isOwn = msg.oderId === currentUser.uid || msg.oderId === currentUserProfile?.oderId;
                div.className = 'message' + (isOwn ? ' own' : '');

                const initial = (msg.user || '?').charAt(0).toUpperCase();
                const time = msg.timestamp ? formatTime(msg.timestamp) : '';

                div.innerHTML = `
                    <div class="message-avatar">${initial}</div>
                    <div class="message-content">
                        <div class="message-sender">${escapeHtml(msg.user || 'Anonyme')}</div>
                        <div class="message-text">${formatMessageText(msg)}</div>
                        <div class="message-time">${time}</div>
                    </div>
                `;
            }

            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        function formatMessageText(msg) {
            if (msg.type === 'gif' && msg.url) {
                return `<img src="${escapeHtml(msg.url)}" alt="GIF" onerror="this.style.display='none'">`;
            }
            if (msg.type === 'voice' && msg.audioData) {
                const dur = msg.duration || 0;
                const min = Math.floor(dur / 60);
                const sec = dur % 60;
                const durStr = min + ':' + (sec < 10 ? '0' : '') + sec;
                const playerId = 'vp_' + Date.now() + '_' + Math.random().toString(36).substring(2, 6);
                // Stocker les data audio dans un attribut data pour chargement differe
                return `<div class="voice-msg-player" id="${playerId}" data-audio-src="${msg.audioData}">
                    <button class="voice-msg-play" onclick="playVoiceMsg('${playerId}')" title="Ã‰couter">â–¶</button>
                    <div class="voice-msg-info">
                        <div class="voice-msg-bar" onclick="seekVoiceMsg(event, '${playerId}')">
                            <div class="voice-msg-progress"></div>
                        </div>
                        <span class="voice-msg-duration">${durStr}</span>
                    </div>
                </div>`;
            }
            return escapeHtml(msg.text || '');
        }

        // Lecture des messages vocaux
        function playVoiceMsg(playerId) {
            const player = document.getElementById(playerId);
            if (!player) return;
            const btn = player.querySelector('.voice-msg-play');
            const progress = player.querySelector('.voice-msg-progress');
            const durLabel = player.querySelector('.voice-msg-duration');

            // Creer l'element audio a la demande (evite les problemes de preload)
            let audio = player.querySelector('audio');
            if (!audio) {
                const src = player.getAttribute('data-audio-src');
                if (!src) {
                    console.error('Pas de source audio pour', playerId);
                    return;
                }
                audio = document.createElement('audio');
                audio.preload = 'auto';
                audio.src = src;
                player.appendChild(audio);

                audio.addEventListener('error', (e) => {
                    console.error('Erreur chargement audio:', audio.error);
                    btn.textContent = 'âš ';
                    btn.title = 'Impossible de lire ce message vocal';
                });
            }

            // Arreter tous les autres lecteurs
            document.querySelectorAll('.voice-msg-player audio').forEach(a => {
                if (a !== audio && !a.paused) {
                    a.pause();
                    a.currentTime = 0;
                    const otherBtn = a.closest('.voice-msg-player')?.querySelector('.voice-msg-play');
                    if (otherBtn) otherBtn.textContent = 'â–¶';
                    const otherProg = a.closest('.voice-msg-player')?.querySelector('.voice-msg-progress');
                    if (otherProg) otherProg.style.width = '0%';
                }
            });

            if (audio.paused) {
                btn.textContent = '...';

                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        btn.textContent = 'â¸';
                    }).catch(err => {
                        console.error('Erreur lecture audio:', err);
                        btn.textContent = 'â–¶';
                        if (err.name === 'NotAllowedError') {
                            alert('Appuyez Ã  nouveau pour Ã©couter le message vocal.');
                        }
                    });
                } else {
                    btn.textContent = 'â¸';
                }

                audio.ontimeupdate = () => {
                    if (audio.duration && isFinite(audio.duration)) {
                        const pct = (audio.currentTime / audio.duration) * 100;
                        progress.style.width = pct + '%';
                        const rem = Math.max(0, Math.floor(audio.duration - audio.currentTime));
                        const min = Math.floor(rem / 60);
                        const sec = rem % 60;
                        durLabel.textContent = min + ':' + (sec < 10 ? '0' : '') + sec;
                    }
                };

                audio.onended = () => {
                    btn.textContent = 'â–¶';
                    progress.style.width = '0%';
                    const dur = Math.floor(audio.duration || 0);
                    if (isFinite(dur)) {
                        const min = Math.floor(dur / 60);
                        const sec = dur % 60;
                        durLabel.textContent = min + ':' + (sec < 10 ? '0' : '') + sec;
                    }
                };
            } else {
                audio.pause();
                btn.textContent = 'â–¶';
            }
        }

        function seekVoiceMsg(event, playerId) {
            const player = document.getElementById(playerId);
            if (!player) return;
            const audio = player.querySelector('audio');
            const bar = player.querySelector('.voice-msg-bar');
            if (!audio || !bar || !audio.duration || !isFinite(audio.duration)) return;

            const rect = bar.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const pct = Math.max(0, Math.min(1, x / rect.width));
            audio.currentTime = pct * audio.duration;
        }

        // ==================== SEND MESSAGE ====================
        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const text = input.value.trim();

            if (!text || !currentChat) return;

            // Vider le champ immediatement pour une UX reactive
            input.value = '';

            let path;
            if (currentChatType === 'dm') {
                path = 'dmMessages/' + currentChat;
            } else if (currentChatType === 'group') {
                path = 'groupMessages/' + currentChat;
            }

            const message = {
                type: 'message',
                user: currentUserProfile.pseudo,
                oderId: currentUser.uid,
                senderId: currentUser.uid,
                text: text,
                timestamp: Date.now()
            };

            try {
                await db.ref(path).push(message);

                // IncrÃ©menter le compteur de messages du profil
                db.ref('users/' + currentUser.uid + '/messagesCount').transaction(n => (n || 0) + 1);

                // Update last message in conversation
                if (currentChatType !== 'public') {
                    const update = {
                        lastMessage: text.substring(0, 50),
                        lastTime: Date.now()
                    };

                    if (currentChatType === 'dm') {
                        const conv = conversations[currentChat];
                        if (conv) {
                            for (const oderId of conv.participants) {
                                await db.ref('userConversations/' + oderId + '/' + currentChat).update(update);

                                // Increment unread + email notification for other user
                                if (oderId !== currentUser.uid) {
                                    await db.ref('userConversations/' + oderId + '/' + currentChat + '/unread').transaction(n => (n || 0) + 1);
                                    EmailNotifier.notifyNewMessage(oderId, currentUserProfile.pseudo, text);
                                }
                            }
                        }
                    } else if (currentChatType === 'group') {
                        const groupSnap = await db.ref('groups/' + currentChat + '/members').once('value');
                        if (groupSnap.exists()) {
                            for (const oderId of Object.keys(groupSnap.val())) {
                                await db.ref('userConversations/' + oderId + '/' + currentChat).update(update);

                                if (oderId !== currentUser.uid) {
                                    await db.ref('userConversations/' + oderId + '/' + currentChat + '/unread').transaction(n => (n || 0) + 1);
                                    EmailNotifier.notifyNewMessage(oderId, currentUserProfile.pseudo, text);
                                }
                            }
                        }
                    }
                }
            } catch (err) {
                console.error('Erreur envoi message:', err);
            }
        }

        // ==================== CHAT INFO ====================
        async function openChatInfo() {
            const content = document.getElementById('chatInfoContent');

            if (currentChatType === 'dm') {
                const conv = conversations[currentChat];
                if (conv) {
                    const otherUserId = conv.participants ? conv.participants.find(p => p !== currentUser.uid) : null;
                    const otherPseudo = conv.otherPseudo || (otherUserId && contacts[otherUserId] && contacts[otherUserId].pseudo) || 'Utilisateur';

                    content.innerHTML = `
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div class="conv-avatar user" style="width: 80px; height: 80px; font-size: 2rem; margin: 0 auto 15px;">
                                ${otherPseudo.charAt(0).toUpperCase()}
                            </div>
                            <h3>${escapeHtml(otherPseudo)}</h3>
                            <p style="color: var(--text-secondary);">Message privÃ©</p>
                        </div>
                    `;
                }
            } else if (currentChatType === 'group') {
                const groupSnap = await db.ref('groups/' + currentChat).once('value');
                const group = groupSnap.val();

                if (group) {
                    let membersHTML = '';
                    for (const [oderId, data] of Object.entries(group.members)) {
                        // Pseudo depuis contacts locaux ou profil courant
                        const pseudo = oderId === currentUser.uid
                            ? currentUserProfile.pseudo
                            : (contacts[oderId] && contacts[oderId].pseudo) || 'Utilisateur';
                        const role = data.role === 'admin' ? 'ðŸ‘‘ Admin' : 'Membre';
                        membersHTML += `
                            <div class="user-item">
                                <div class="user-item-avatar">${pseudo.charAt(0).toUpperCase()}</div>
                                <div class="user-item-info">
                                    <div class="user-item-name">${escapeHtml(pseudo)}</div>
                                    <div class="user-item-status">${role}</div>
                                </div>
                            </div>
                        `;
                    }

                    content.innerHTML = `
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div class="conv-avatar group" style="width: 80px; height: 80px; font-size: 2rem; margin: 0 auto 15px;">
                                ${group.name.charAt(0).toUpperCase()}
                            </div>
                            <h3>${escapeHtml(group.name)}</h3>
                            <p style="color: var(--text-secondary);">${escapeHtml(group.description || 'Aucune description')}</p>
                        </div>
                        <h4 style="margin: 20px 0 10px; color: var(--cyan);">ðŸ‘¥ Membres (${Object.keys(group.members).length})</h4>
                        ${membersHTML}
                    `;
                }
            }

            openModal('chatInfo');
        }

        async function leaveGroup() {
            if (!currentChat || currentChatType !== 'group') return;

            if (!confirm('Voulez-vous vraiment quitter ce groupe ?')) return;

            // Remove from group members
            await db.ref('groups/' + currentChat + '/members/' + currentUser.uid).remove();

            // Remove from user conversations
            await db.ref('userConversations/' + currentUser.uid + '/' + currentChat).remove();

            // System message
            await db.ref('groupMessages/' + currentChat).push({
                type: 'system',
                text: `${currentUserProfile.pseudo} a quittÃ© le groupe`,
                timestamp: Date.now()
            });

            closeModal('chatInfo');
            currentChat = null;
            currentChatType = null;
            document.getElementById('noChat').style.display = 'flex';
            document.getElementById('activeChat').style.display = 'none';
        }

        // ==================== MODALS ====================
        function openModal(name) {
            document.getElementById('modal' + capitalize(name)).classList.add('active');
        }

        function closeModal(name) {
            document.getElementById('modal' + capitalize(name)).classList.remove('active');
        }

        // ==================== MOBILE ====================
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            sidebar.classList.toggle('open');
            overlay.classList.toggle('active', sidebar.classList.contains('open'));
        }

        function closeSidebar() {
            document.getElementById('sidebar').classList.remove('open');
            document.getElementById('sidebarOverlay').classList.remove('active');
        }

        // Gestion du clavier virtuel Android
        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        if (isMobile && window.visualViewport) {
            window.visualViewport.addEventListener('resize', () => {
                const container = document.getElementById('messagesContainer');
                if (container) {
                    setTimeout(() => container.scrollTop = container.scrollHeight, 100);
                }
            });

            const msgInput = document.getElementById('messageInput');
            if (msgInput) {
                msgInput.addEventListener('focus', () => {
                    setTimeout(() => {
                        const container = document.getElementById('messagesContainer');
                        if (container) container.scrollTop = container.scrollHeight;
                        msgInput.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                    }, 300);
                });
            }
        }

        // ==================== UTILITIES ====================
        // Charge depuis js/firebase-config.js

        function formatTime(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();

            if (date.toDateString() === now.toDateString()) {
                return date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
            } else {
                return date.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' });
            }
        }

        function capitalize(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        // ==================== VOICE RECORDER ====================
        const VoiceRecorder = {
            mediaRecorder: null,
            audioChunks: [],
            stream: null,
            isRecording: false,
            startTime: 0,
            timerInterval: null,
            analyser: null,
            animFrame: null,
            MAX_DURATION: 60, // secondes max

            toggle() {
                if (this.isRecording) {
                    this.stopAndSend();
                } else {
                    this.start();
                }
            },

            async start() {
                if (!currentChat) return;

                // Verifier que MediaRecorder est supporte
                if (typeof MediaRecorder === 'undefined') {
                    alert('Votre navigateur ne supporte pas l\'enregistrement audio. Essayez Chrome, Firefox ou Edge.');
                    return;
                }

                try {
                    this.stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                } catch (err) {
                    console.error('getUserMedia error:', err.name, err.message);
                    if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                        alert('Autorisez l\'accÃ¨s au micro dans les paramÃ¨tres de votre navigateur.');
                    } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                        alert('Aucun microphone dÃ©tectÃ©.');
                    } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
                        alert('Le micro est utilisÃ© par une autre application. Fermez-la et rÃ©essayez.');
                    } else {
                        alert('Impossible d\'accÃ©der au micro : ' + (err.message || err.name));
                    }
                    return;
                }

                // Choisir le format supporte - tester plusieurs options
                const mimeTypes = [
                    'audio/webm;codecs=opus',
                    'audio/webm',
                    'audio/ogg;codecs=opus',
                    'audio/ogg',
                    'audio/mp4',
                    'audio/mpeg',
                    '' // Laisser le navigateur choisir
                ];
                let selectedMime = '';
                for (const mime of mimeTypes) {
                    if (!mime || MediaRecorder.isTypeSupported(mime)) {
                        selectedMime = mime;
                        break;
                    }
                }

                this.audioChunks = [];
                try {
                    const options = selectedMime ? { mimeType: selectedMime } : {};
                    this.mediaRecorder = new MediaRecorder(this.stream, options);
                } catch (err) {
                    console.error('MediaRecorder creation error:', err);
                    // Deuxieme tentative sans options
                    try {
                        this.mediaRecorder = new MediaRecorder(this.stream);
                    } catch (err2) {
                        console.error('MediaRecorder fallback error:', err2);
                        alert('Impossible de dÃ©marrer l\'enregistrement audio.');
                        this.stream.getTracks().forEach(t => t.stop());
                        this.stream = null;
                        return;
                    }
                }

                console.log('ðŸŽ™ï¸ MediaRecorder dÃ©marrÃ©, mimeType:', this.mediaRecorder.mimeType);

                this.mediaRecorder.ondataavailable = (e) => {
                    if (e.data && e.data.size > 0) this.audioChunks.push(e.data);
                };

                this.mediaRecorder.onerror = (e) => {
                    console.error('MediaRecorder error:', e.error);
                    this.cancel();
                };

                this.mediaRecorder.start(250); // chunks toutes les 250ms
                this.isRecording = true;
                this.startTime = Date.now();

                // UI
                document.getElementById('voiceRecordBtn').classList.add('recording');
                document.getElementById('voiceRecorderBar').classList.add('active');
                document.getElementById('messageForm').style.display = 'none';

                // Timer
                this.timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                    const min = Math.floor(elapsed / 60);
                    const sec = elapsed % 60;
                    document.getElementById('voiceRecTimer').textContent = min + ':' + (sec < 10 ? '0' : '') + sec;

                    // Limite de duree
                    if (elapsed >= this.MAX_DURATION) {
                        this.stopAndSend();
                    }
                }, 500);

                // Visualisation des ondes
                this.startWaveViz();
            },

            startWaveViz() {
                try {
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    const source = ctx.createMediaStreamSource(this.stream);
                    this.analyser = ctx.createAnalyser();
                    this.analyser.fftSize = 64;
                    source.connect(this.analyser);

                    const wave = document.getElementById('voiceRecWave');
                    const bars = 20;
                    wave.innerHTML = '';
                    for (let i = 0; i < bars; i++) {
                        const span = document.createElement('span');
                        span.style.height = '4px';
                        wave.appendChild(span);
                    }

                    const dataArray = new Uint8Array(this.analyser.frequencyBinCount);

                    const draw = () => {
                        if (!this.isRecording) return;
                        this.animFrame = requestAnimationFrame(draw);
                        this.analyser.getByteFrequencyData(dataArray);

                        const barEls = wave.querySelectorAll('span');
                        for (let i = 0; i < barEls.length; i++) {
                            const val = dataArray[i] || 0;
                            const h = Math.max(4, (val / 255) * 24);
                            barEls[i].style.height = h + 'px';
                        }
                    };
                    draw();
                    this._vizCtx = ctx;
                } catch (e) {
                    console.warn('Visualisation audio non disponible:', e);
                }
            },

            cancel() {
                if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                    this.mediaRecorder.onstop = () => {}; // Ignorer le stop
                    this.mediaRecorder.stop();
                }
                this.cleanup();
            },

            async stopAndSend() {
                if (!this.mediaRecorder || this.mediaRecorder.state === 'inactive') {
                    this.cleanup();
                    return;
                }

                const duration = Math.floor((Date.now() - this.startTime) / 1000);

                // Trop court (moins de 1s)
                if (duration < 1) {
                    this.cancel();
                    return;
                }

                // Sauvegarder le mimeType avant le stop
                const mimeType = this.mediaRecorder.mimeType;

                return new Promise(resolve => {
                    this.mediaRecorder.onstop = async () => {
                        if (this.audioChunks.length === 0) {
                            console.error('Aucune donnÃ©e audio enregistrÃ©e');
                            alert('L\'enregistrement n\'a capturÃ© aucun son. VÃ©rifiez votre micro.');
                            this.cleanup();
                            resolve();
                            return;
                        }

                        const blob = new Blob(this.audioChunks, { type: mimeType || 'audio/webm' });
                        console.log('ðŸŽ™ï¸ Audio blob:', blob.size, 'octets, type:', blob.type);

                        // Verifier la taille (max ~500KB pour Firebase Realtime DB)
                        if (blob.size > 500000) {
                            alert('Message vocal trop long. Essayez un enregistrement plus court.');
                            this.cleanup();
                            resolve();
                            return;
                        }

                        if (blob.size < 100) {
                            alert('L\'enregistrement semble vide. VÃ©rifiez que votre micro fonctionne.');
                            this.cleanup();
                            resolve();
                            return;
                        }

                        // Convertir en base64
                        const reader = new FileReader();
                        reader.onerror = () => {
                            console.error('FileReader error');
                            alert('Erreur lors de la conversion audio.');
                            this.cleanup();
                            resolve();
                        };
                        reader.onloadend = async () => {
                            const audioData = reader.result; // data:audio/webm;base64,...
                            console.log('ðŸŽ™ï¸ Audio base64 prÃªt, taille:', audioData.length);
                            await this.sendVoiceMessage(audioData, duration);
                            this.cleanup();
                            resolve();
                        };
                        reader.readAsDataURL(blob);
                    };
                    this.mediaRecorder.stop();
                });
            },

            async sendVoiceMessage(audioData, duration) {
                if (!currentChat) return;

                let path;
                if (currentChatType === 'dm') {
                    path = 'dmMessages/' + currentChat;
                } else if (currentChatType === 'group') {
                    path = 'groupMessages/' + currentChat;
                } else return;

                const message = {
                    type: 'voice',
                    user: currentUserProfile.pseudo,
                    oderId: currentUser.uid,
                    senderId: currentUser.uid,
                    audioData: audioData,
                    duration: duration,
                    text: 'ðŸŽ™ï¸ Message vocal',
                    timestamp: Date.now()
                };

                try {
                    await db.ref(path).push(message);
                    db.ref('users/' + currentUser.uid + '/messagesCount').transaction(n => (n || 0) + 1);

                    const update = {
                        lastMessage: 'ðŸŽ™ï¸ Message vocal',
                        lastTime: Date.now()
                    };

                    if (currentChatType === 'dm') {
                        const conv = conversations[currentChat];
                        if (conv) {
                            for (const uid of conv.participants) {
                                await db.ref('userConversations/' + uid + '/' + currentChat).update(update);
                                if (uid !== currentUser.uid) {
                                    await db.ref('userConversations/' + uid + '/' + currentChat + '/unread').transaction(n => (n || 0) + 1);
                                    EmailNotifier.notifyNewMessage(uid, currentUserProfile.pseudo, 'ðŸŽ™ï¸ Message vocal');
                                }
                            }
                        }
                    } else if (currentChatType === 'group') {
                        const groupSnap = await db.ref('groups/' + currentChat + '/members').once('value');
                        if (groupSnap.exists()) {
                            for (const uid of Object.keys(groupSnap.val())) {
                                await db.ref('userConversations/' + uid + '/' + currentChat).update(update);
                                if (uid !== currentUser.uid) {
                                    await db.ref('userConversations/' + uid + '/' + currentChat + '/unread').transaction(n => (n || 0) + 1);
                                    EmailNotifier.notifyNewMessage(uid, currentUserProfile.pseudo, 'ðŸŽ™ï¸ Message vocal');
                                }
                            }
                        }
                    }
                } catch (err) {
                    console.error('Erreur envoi message vocal:', err);
                }
            },

            cleanup() {
                this.isRecording = false;

                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
                if (this.animFrame) {
                    cancelAnimationFrame(this.animFrame);
                    this.animFrame = null;
                }
                if (this._vizCtx && this._vizCtx.state !== 'closed') {
                    this._vizCtx.close().catch(() => {});
                    this._vizCtx = null;
                }
                if (this.stream) {
                    this.stream.getTracks().forEach(t => t.stop());
                    this.stream = null;
                }

                this.mediaRecorder = null;
                this.audioChunks = [];
                this.analyser = null;

                // Reset UI
                document.getElementById('voiceRecordBtn').classList.remove('recording');
                document.getElementById('voiceRecorderBar').classList.remove('active');
                document.getElementById('messageForm').style.display = 'flex';
                document.getElementById('voiceRecTimer').textContent = '0:00';
                document.getElementById('voiceRecWave').innerHTML = '';
            }
        };

        // ==================== VIDEO CALL PRIVE (DM) ====================
        function startVideoCall() {
            if (!currentChat || (currentChatType !== 'dm' && currentChatType !== 'group')) return;
            const conv = conversations[currentChat];
            if (!conv) return;

            if (currentChatType === 'dm') {
                const otherUserId = conv.participants ? conv.participants.find(p => p !== currentUser.uid) : null;
                const otherPseudo = conv.otherPseudo || (otherUserId && contacts[otherUserId] && contacts[otherUserId].pseudo) || 'Utilisateur';
                document.getElementById('vcCallName').textContent = otherPseudo;
                DMVideoChat.currentConvId = currentChat;
                DMVideoChat.currentCallType = 'dm';
            } else if (currentChatType === 'group') {
                document.getElementById('vcCallName').textContent = conv.name || 'Groupe';
                DMVideoChat.currentConvId = currentChat;
                DMVideoChat.currentCallType = 'group';
            }
            openModal('videoCall');
        }

        const DMVideoChat = {
            joined: false,
            localStream: null,
            localVideoEl: null,
            peers: {},
            remoteStreams: {},
            myVideoId: null,
            currentConvId: null,
            currentCallType: 'dm', // 'dm' or 'group'
            roomRef: null,
            participantsRef: null,
            signalsRef: null,
            micEnabled: true,
            camEnabled: true,
            _qualityInterval: null,
            currentQuality: 'high',

            ICE_SERVERS: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    {
                        urls: 'turn:openrelay.metered.ca:80',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    },
                    {
                        urls: 'turn:openrelay.metered.ca:443',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    },
                    {
                        urls: 'turn:openrelay.metered.ca:443?transport=tcp',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    }
                ],
                iceCandidatePoolSize: 10
            },

            VIDEO_CONSTRAINTS: {
                high: { width: { ideal: 1280, max: 1920 }, height: { ideal: 720, max: 1080 }, frameRate: { ideal: 30 }, facingMode: 'user' },
                medium: { width: { ideal: 640, max: 1280 }, height: { ideal: 480, max: 720 }, frameRate: { ideal: 24 }, facingMode: 'user' },
                low: { width: { ideal: 320, max: 640 }, height: { ideal: 240, max: 480 }, frameRate: { ideal: 15 }, facingMode: 'user' }
            },

            AUDIO_CONSTRAINTS: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
                sampleRate: 48000,
                channelCount: 1
            },

            BITRATE: { videoMax: 1500, videoMin: 150, audioMax: 64 },

            async joinCall() {
                if (this.joined || !this.currentConvId) return;
                const joinBtn = document.getElementById('vcJoinBtn');
                joinBtn.disabled = true;
                joinBtn.textContent = 'Connexion...';

                if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                    alert('La vidÃ©o nÃ©cessite une connexion HTTPS sÃ©curisÃ©e.');
                    joinBtn.disabled = false;
                    joinBtn.textContent = 'ðŸ“¹ Rejoindre l\'appel';
                    return;
                }

                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    alert('Votre navigateur ne supporte pas la vidÃ©o.');
                    joinBtn.disabled = false;
                    joinBtn.textContent = 'ðŸ“¹ Rejoindre l\'appel';
                    return;
                }

                // Limite participants : 2 pour DM, 6 pour groupe
                const maxParticipants = this.currentCallType === 'group' ? 6 : 2;
                const roomPath = this.currentCallType === 'group' ? 'groupVideoRoom/' : 'dmVideoRoom/';
                try {
                    const snap = await db.ref(roomPath + this.currentConvId + '/participants').once('value');
                    if (snap.exists() && Object.keys(snap.val()).length >= maxParticipants) {
                        alert(maxParticipants === 2 ? 'L\'appel est dÃ©jÃ  en cours avec 2 participants.' : 'L\'appel est complet (' + maxParticipants + ' participants max).');
                        joinBtn.disabled = false;
                        joinBtn.textContent = 'ðŸ“¹ Rejoindre l\'appel';
                        return;
                    }
                } catch (e) {}

                // Obtenir le flux media
                const qualities = ['high', 'medium', 'low'];
                let streamOk = false;
                for (const q of qualities) {
                    try {
                        this.localStream = await navigator.mediaDevices.getUserMedia({
                            video: this.VIDEO_CONSTRAINTS[q],
                            audio: this.AUDIO_CONSTRAINTS
                        });
                        this.currentQuality = q;
                        streamOk = true;
                        break;
                    } catch (err) {
                        console.warn('getUserMedia failed at', q, ':', err.name);
                    }
                }
                if (!streamOk) {
                    try {
                        this.localStream = await navigator.mediaDevices.getUserMedia({ video: false, audio: this.AUDIO_CONSTRAINTS });
                        this.camEnabled = false;
                        streamOk = true;
                    } catch (err2) {
                        let msg = 'Impossible d\'accÃ©der Ã  la camÃ©ra ou au micro.\n\n';
                        if (err2.name === 'NotAllowedError') msg += 'Autorisez l\'accÃ¨s dans les paramÃ¨tres de votre navigateur.';
                        else if (err2.name === 'NotFoundError') msg += 'Aucune camÃ©ra ou micro dÃ©tectÃ©.';
                        else msg += 'Erreur : ' + (err2.message || err2.name);
                        alert(msg);
                        joinBtn.disabled = false;
                        joinBtn.textContent = 'ðŸ“¹ Rejoindre l\'appel';
                        return;
                    }
                }

                this.joined = true;
                this.myVideoId = 'v_' + crypto.getRandomValues(new Uint32Array(1))[0].toString(36) + '_' + Date.now();

                // Afficher l'UI
                document.getElementById('vcJoinScreen').style.display = 'none';
                document.getElementById('vcControls').style.display = 'flex';

                const grid = document.getElementById('vcVideoGrid');
                grid.style.display = 'flex';
                grid.innerHTML = '';

                // Video locale
                this.addVideoCell(this.myVideoId, currentUserProfile.pseudo + ' (vous)', true);
                const localVideoEl = document.querySelector(`[data-peer="${this.myVideoId}"] video`);
                if (localVideoEl) {
                    localVideoEl.srcObject = this.localStream;
                    localVideoEl.muted = true;
                    this.playVideo(localVideoEl);
                }
                this.localVideoEl = localVideoEl;

                this.startQualityMonitor();

                // Firebase signaling par conversation
                this.roomRef = db.ref((this.currentCallType === 'group' ? 'groupVideoRoom/' : 'dmVideoRoom/') + this.currentConvId);
                this.participantsRef = this.roomRef.child('participants');
                this.signalsRef = this.roomRef.child('signals');

                const myRef = this.participantsRef.child(this.myVideoId);
                myRef.set({
                    uid: currentUser.uid,
                    name: currentUserProfile.pseudo,
                    joinedAt: Date.now(),
                    mic: this.micEnabled,
                    cam: this.camEnabled
                });
                myRef.onDisconnect().remove();
                this.signalsRef.child(this.myVideoId).onDisconnect().remove();

                // Signaler l'appel entrant aux autres participants
                this.notifyIncomingCall();

                // Ecouter les participants
                this.participantsRef.on('child_added', snap => {
                    const peerId = snap.key;
                    if (peerId === this.myVideoId) return;
                    const data = snap.val();
                    this.addVideoCell(peerId, data.name, false);
                    this.updateParticipantCount();
                    if (this.myVideoId > peerId) {
                        this.createOffer(peerId);
                    }
                });

                this.participantsRef.on('child_removed', snap => {
                    const peerId = snap.key;
                    this.removePeer(peerId);
                    this.updateParticipantCount();
                });

                this.participantsRef.on('child_changed', snap => {
                    const peerId = snap.key;
                    if (peerId === this.myVideoId) return;
                    const data = snap.val();
                    const nameTag = document.querySelector(`[data-peer="${peerId}"] .vc-nametag`);
                    if (nameTag) {
                        nameTag.innerHTML = data.name + (!data.mic ? ' ðŸ”‡' : '');
                    }
                });

                // Ecouter les signaux
                this.signalsRef.child(this.myVideoId).on('child_added', async snap => {
                    const signal = snap.val();
                    if (!signal) return;
                    try {
                        if (signal.type === 'offer') await this.handleOffer(signal.from, signal.sdp);
                        else if (signal.type === 'answer') await this.handleAnswer(signal.from, signal.sdp);
                        else if (signal.type === 'ice') await this.handleIce(signal.from, signal.candidate);
                    } catch (e) {
                        console.error('Signal error:', e);
                    }
                    snap.ref.remove();
                });

                this.updateParticipantCount();
            },

            async createOffer(peerId) {
                const pc = this.createPeerConnection(peerId);
                try {
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    await this.signalsRef.child(peerId).push({
                        type: 'offer', from: this.myVideoId, sdp: offer.sdp
                    });
                } catch (e) { console.error('Offer error:', e); }
            },

            async handleOffer(fromId, sdp) {
                const pc = this.createPeerConnection(fromId);
                try {
                    await pc.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp }));
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    await this.signalsRef.child(fromId).push({
                        type: 'answer', from: this.myVideoId, sdp: answer.sdp
                    });
                } catch (e) { console.error('Answer error:', e); }
            },

            async handleAnswer(fromId, sdp) {
                const pc = this.peers[fromId];
                if (pc && pc.signalingState !== 'stable') {
                    try { await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp })); }
                    catch (e) { console.error('Set answer error:', e); }
                }
            },

            async handleIce(fromId, candidate) {
                const pc = this.peers[fromId];
                if (pc && candidate) {
                    try { await pc.addIceCandidate(new RTCIceCandidate(candidate)); }
                    catch (e) { console.error('ICE error:', e); }
                }
            },

            createPeerConnection(peerId) {
                if (this.peers[peerId]) this.peers[peerId].close();
                const pc = new RTCPeerConnection(this.ICE_SERVERS);
                this.peers[peerId] = pc;

                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => {
                        const sender = pc.addTrack(track, this.localStream);
                        if (track.kind === 'video') this.applyBitrateLimit(sender, 'video');
                        else if (track.kind === 'audio') this.applyBitrateLimit(sender, 'audio');
                    });
                }

                pc.onicecandidate = event => {
                    if (event.candidate) {
                        this.signalsRef.child(peerId).push({
                            type: 'ice', from: this.myVideoId, candidate: event.candidate.toJSON()
                        });
                    }
                };

                pc.ontrack = event => {
                    const stream = event.streams[0];
                    if (stream) {
                        this.remoteStreams[peerId] = stream;
                        const videoEl = document.querySelector(`[data-peer="${peerId}"] video`);
                        if (videoEl) {
                            videoEl.srcObject = stream;
                            this.playVideo(videoEl);
                        }
                    }
                };

                pc.onconnectionstatechange = () => {
                    if (pc.connectionState === 'failed') {
                        pc.close();
                        delete this.peers[peerId];
                        if (this.myVideoId > peerId) {
                            setTimeout(() => this.createOffer(peerId), 1000);
                        }
                    }
                };

                return pc;
            },

            async applyBitrateLimit(sender, kind) {
                try {
                    const params = sender.getParameters();
                    if (!params.encodings || params.encodings.length === 0) params.encodings = [{}];
                    if (kind === 'video') {
                        params.encodings[0].maxBitrate = this.BITRATE.videoMax * 1000;
                        params.degradationPreference = 'balanced';
                    } else {
                        params.encodings[0].maxBitrate = this.BITRATE.audioMax * 1000;
                    }
                    await sender.setParameters(params);
                } catch (e) {}
            },

            startQualityMonitor() {
                if (this._qualityInterval) clearInterval(this._qualityInterval);
                this._qualityInterval = setInterval(() => this.checkNetworkQuality(), 5000);
            },

            stopQualityMonitor() {
                if (this._qualityInterval) { clearInterval(this._qualityInterval); this._qualityInterval = null; }
            },

            async checkNetworkQuality() {
                for (const [peerId, pc] of Object.entries(this.peers)) {
                    try {
                        const stats = await pc.getStats();
                        stats.forEach(report => {
                            if (report.type === 'outbound-rtp' && report.kind === 'video') {
                                const lossRate = (report.packetsLost || 0) / ((report.packetsSent || 1) + (report.packetsLost || 0));
                                if (lossRate > 0.1 && this.currentQuality !== 'low') this.downgradeQuality();
                                else if (lossRate < 0.02 && this.currentQuality !== 'high') this.upgradeQuality();
                            }
                        });
                    } catch (e) {}
                }
            },

            async downgradeQuality() {
                const levels = ['high', 'medium', 'low'];
                const idx = levels.indexOf(this.currentQuality);
                if (idx < levels.length - 1) {
                    this.currentQuality = levels[idx + 1];
                    await this.applyVideoConstraints(this.currentQuality);
                }
            },

            async upgradeQuality() {
                const levels = ['high', 'medium', 'low'];
                const idx = levels.indexOf(this.currentQuality);
                if (idx > 0) {
                    this.currentQuality = levels[idx - 1];
                    await this.applyVideoConstraints(this.currentQuality);
                }
            },

            async applyVideoConstraints(quality) {
                if (!this.localStream) return;
                const videoTrack = this.localStream.getVideoTracks()[0];
                if (!videoTrack) return;
                try {
                    await videoTrack.applyConstraints(this.VIDEO_CONSTRAINTS[quality]);
                    const bitrateMap = { high: 1500, medium: 800, low: 300 };
                    for (const pc of Object.values(this.peers)) {
                        for (const sender of pc.getSenders()) {
                            if (sender.track && sender.track.kind === 'video') {
                                const params = sender.getParameters();
                                if (params.encodings && params.encodings.length > 0) {
                                    params.encodings[0].maxBitrate = (bitrateMap[quality] || 800) * 1000;
                                    await sender.setParameters(params);
                                }
                            }
                        }
                    }
                } catch (e) {}
            },

            playVideo(videoEl, retries = 5) {
                if (!videoEl) return;
                videoEl.controls = false;
                videoEl.playsInline = true;
                videoEl.setAttribute('playsinline', '');
                const attempt = () => {
                    const p = videoEl.play();
                    if (p && p.catch) {
                        p.catch(() => {
                            if (retries > 0) { retries--; setTimeout(attempt, 500); }
                        });
                    }
                };
                if (videoEl.readyState >= 2) attempt();
                else {
                    videoEl.addEventListener('loadedmetadata', () => attempt(), { once: true });
                    setTimeout(attempt, 1000);
                }
            },

            addVideoCell(peerId, name, isLocal) {
                const grid = document.getElementById('vcVideoGrid');
                if (grid.querySelector(`[data-peer="${peerId}"]`)) return;

                const cell = document.createElement('div');
                cell.className = 'vc-cell' + (isLocal ? ' local' : '');
                cell.dataset.peer = peerId;

                const video = document.createElement('video');
                video.autoplay = true;
                video.playsInline = true;
                video.setAttribute('playsinline', '');
                video.controls = false;
                if (isLocal) video.muted = true;
                cell.appendChild(video);

                const tag = document.createElement('div');
                tag.className = 'vc-nametag';
                tag.textContent = name || '?';
                cell.appendChild(tag);

                grid.appendChild(cell);
            },

            removePeer(peerId) {
                if (this.peers[peerId]) { this.peers[peerId].close(); delete this.peers[peerId]; }
                delete this.remoteStreams[peerId];
                const cell = document.querySelector(`[data-peer="${peerId}"]`);
                if (cell) cell.remove();
                if (this.signalsRef) this.signalsRef.child(peerId).child(this.myVideoId).remove();
            },

            updateParticipantCount() {
                if (!this.participantsRef) return;
                this.participantsRef.once('value', snap => {
                    const n = snap.numChildren();
                    document.getElementById('vcParticipantCount').textContent = n + ' en appel';
                });
            },

            toggleMic() {
                if (!this.localStream) return;
                this.micEnabled = !this.micEnabled;
                this.localStream.getAudioTracks().forEach(t => t.enabled = this.micEnabled);
                const btn = document.getElementById('vcMicBtn');
                btn.textContent = this.micEnabled ? 'ðŸŽ¤' : 'ðŸ”‡';
                btn.classList.toggle('off', !this.micEnabled);
                if (this.participantsRef && this.myVideoId) {
                    this.participantsRef.child(this.myVideoId).update({ mic: this.micEnabled });
                }
            },

            toggleCam() {
                if (!this.localStream) return;
                const videoTracks = this.localStream.getVideoTracks();
                if (videoTracks.length === 0) return;
                this.camEnabled = !this.camEnabled;
                videoTracks.forEach(t => t.enabled = this.camEnabled);
                const btn = document.getElementById('vcCamBtn');
                btn.textContent = this.camEnabled ? 'ðŸ“¹' : 'ðŸ“·';
                btn.classList.toggle('off', !this.camEnabled);
                if (this.participantsRef && this.myVideoId) {
                    this.participantsRef.child(this.myVideoId).update({ cam: this.camEnabled });
                }
            },

            // Signaler l'appel aux autres participants de la conversation
            async notifyIncomingCall() {
                if (!this.currentConvId || !currentUser) return;
                const callData = {
                    callerUid: currentUser.uid,
                    callerName: currentUserProfile.pseudo,
                    convId: this.currentConvId,
                    chatType: this.currentCallType,
                    timestamp: Date.now()
                };

                try {
                    if (this.currentCallType === 'dm') {
                        const conv = conversations[this.currentConvId];
                        if (conv && conv.participants) {
                            for (const uid of conv.participants) {
                                if (uid !== currentUser.uid) {
                                    const callRef = db.ref('incomingCalls/' + uid).push(callData);
                                    callRef.onDisconnect().remove();
                                    // Auto-suppression apres 35s
                                    setTimeout(() => callRef.remove(), 35000);
                                }
                            }
                        }
                    } else if (this.currentCallType === 'group') {
                        const groupSnap = await db.ref('groups/' + this.currentConvId + '/members').once('value');
                        if (groupSnap.exists()) {
                            for (const uid of Object.keys(groupSnap.val())) {
                                if (uid !== currentUser.uid) {
                                    const callRef = db.ref('incomingCalls/' + uid).push(callData);
                                    callRef.onDisconnect().remove();
                                    setTimeout(() => callRef.remove(), 35000);
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error('Erreur signal appel entrant:', e);
                }
            },

            leaveCall() {
                this.joined = false;
                this.stopQualityMonitor();

                Object.keys(this.peers).forEach(id => { this.peers[id].close(); });
                this.peers = {};
                this.remoteStreams = {};

                if (this.localStream) {
                    this.localStream.getTracks().forEach(t => t.stop());
                    this.localStream = null;
                }

                if (this.participantsRef && this.myVideoId) this.participantsRef.child(this.myVideoId).remove();
                if (this.signalsRef && this.myVideoId) this.signalsRef.child(this.myVideoId).remove();

                if (this.participantsRef) this.participantsRef.off();
                if (this.signalsRef && this.myVideoId) this.signalsRef.child(this.myVideoId).off();

                if (this.localVideoEl) { this.localVideoEl.srcObject = null; this.localVideoEl = null; }
                document.getElementById('vcVideoGrid').innerHTML = '';
                document.getElementById('vcVideoGrid').style.display = 'none';
                document.getElementById('vcControls').style.display = 'none';
                document.getElementById('vcJoinScreen').style.display = 'block';

                const joinBtn = document.getElementById('vcJoinBtn');
                joinBtn.disabled = false;
                joinBtn.textContent = 'ðŸ“¹ Rejoindre l\'appel';

                this.micEnabled = true;
                this.camEnabled = true;
                document.getElementById('vcMicBtn').textContent = 'ðŸŽ¤';
                document.getElementById('vcMicBtn').classList.remove('off');
                document.getElementById('vcCamBtn').textContent = 'ðŸ“¹';
                document.getElementById('vcCamBtn').classList.remove('off');

                closeModal('videoCall');
            }
        };

        // Cleanup video et appels a la fermeture
        window.addEventListener('beforeunload', () => {
            if (DMVideoChat.joined) DMVideoChat.leaveCall();
            IncomingCallSystem.stopListening();
        });

        // ==================== NOTIFICATION SYSTEM ====================
        const NotifSystem = {
            _soundCtx: null,
            _permissionAsked: false,
            _pageTitle: document.title,
            _titleInterval: null,
            _totalUnread: 0,

            init() {
                // Demander la permission pour les notifications navigateur
                if ('Notification' in window && Notification.permission === 'default') {
                    // On demande apres une interaction utilisateur
                    const askOnce = () => {
                        Notification.requestPermission();
                        document.removeEventListener('click', askOnce);
                    };
                    document.addEventListener('click', askOnce);
                }

                // Ecouter les nouveaux messages (toutes les conversations)
                this.listenNewMessages();
                // Ecouter les nouvelles demandes de contact
                this.listenContactRequests();
                // Gerer le focus/blur pour le titre clignotant
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden) {
                        this.stopTitleBlink();
                    }
                });
            },

            // --- Son de notification ---
            playSound(type) {
                try {
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    gain.gain.value = 0.15;

                    if (type === 'message') {
                        osc.frequency.value = 880;
                        osc.type = 'sine';
                        osc.start();
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                        osc.stop(ctx.currentTime + 0.3);
                    } else if (type === 'contact') {
                        osc.frequency.value = 660;
                        osc.type = 'triangle';
                        osc.start();
                        setTimeout(() => {
                            const osc2 = ctx.createOscillator();
                            const gain2 = ctx.createGain();
                            osc2.connect(gain2);
                            gain2.connect(ctx.destination);
                            gain2.gain.value = 0.15;
                            osc2.frequency.value = 990;
                            osc2.type = 'triangle';
                            osc2.start();
                            gain2.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                            osc2.stop(ctx.currentTime + 0.3);
                        }, 150);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                        osc.stop(ctx.currentTime + 0.2);
                    }
                } catch (e) { /* Audio non supporte */ }
            },

            // --- Toast in-app ---
            showToast(type, title, text, onClick) {
                const container = document.getElementById('notifContainer');
                const toast = document.createElement('div');
                toast.className = 'notif-toast ' + type;
                toast.innerHTML = `
                    <div class="notif-toast-icon">${type === 'message' ? 'ðŸ’¬' : 'ðŸ‘‹'}</div>
                    <div class="notif-toast-body">
                        <div class="notif-toast-title">${escapeHtml(title)}</div>
                        <div class="notif-toast-text">${escapeHtml(text)}</div>
                    </div>
                    <button class="notif-toast-close" onclick="event.stopPropagation();this.parentElement.remove();">âœ•</button>
                `;

                if (onClick) {
                    toast.addEventListener('click', () => {
                        onClick();
                        toast.remove();
                    });
                }

                container.appendChild(toast);

                // Auto-suppression apres 5s
                setTimeout(() => {
                    if (toast.parentElement) toast.remove();
                }, 5000);
            },

            // --- Notification navigateur ---
            showBrowserNotif(title, body, onClick) {
                if ('Notification' in window && Notification.permission === 'granted') {
                    const notif = new Notification(title, {
                        body,
                        icon: 'ðŸ’¬',
                        tag: 'msg-' + Date.now(),
                        silent: true // On a deja notre propre son
                    });
                    if (onClick) {
                        notif.onclick = () => {
                            window.focus();
                            onClick();
                            notif.close();
                        };
                    }
                    setTimeout(() => notif.close(), 5000);
                }
            },

            // --- Titre clignotant ---
            startTitleBlink(text) {
                if (this._titleInterval) return;
                let show = true;
                this._titleInterval = setInterval(() => {
                    document.title = show ? text : this._pageTitle;
                    show = !show;
                }, 1000);
            },

            stopTitleBlink() {
                if (this._titleInterval) {
                    clearInterval(this._titleInterval);
                    this._titleInterval = null;
                    document.title = this._pageTitle;
                }
            },

            // --- Badge total non lu (mobile) ---
            updateTotalUnread(count) {
                this._totalUnread = count;
                const badge = document.getElementById('mobileUnreadBadge');
                if (badge) {
                    badge.textContent = count;
                    badge.style.display = count > 0 ? 'inline-flex' : 'none';
                }
                // Mettre a jour le titre de la page
                if (count > 0) {
                    this._pageTitle = `(${count}) Messagerie ðŸ’¬ TLD`;
                } else {
                    this._pageTitle = 'Messagerie ðŸ’¬ TLD';
                }
                if (!this._titleInterval) {
                    document.title = this._pageTitle;
                }
            },

            // --- Ecouter les nouveaux messages ---
            listenNewMessages() {
                db.ref('userConversations/' + currentUser.uid).on('value', snapshot => {
                    if (!snapshot.exists()) {
                        this.updateTotalUnread(0);
                        return;
                    }

                    let totalUnread = 0;
                    const convs = snapshot.val();

                    for (const [convId, data] of Object.entries(convs)) {
                        totalUnread += (data.unread || 0);
                    }

                    this.updateTotalUnread(totalUnread);
                });

                // Ecouter les changements specifiques pour les notifications temps reel
                db.ref('userConversations/' + currentUser.uid).on('child_changed', snapshot => {
                    const data = snapshot.val();
                    const convId = snapshot.key;
                    if (!data || !data.unread || data.unread <= 0) return;

                    // Ne pas notifier si c'est la conversation active
                    if (convId === currentChat) return;

                    const senderName = data.type === 'dm' ? (data.otherPseudo || 'Quelqu\'un') : (data.name || 'Groupe');
                    const preview = data.lastMessage || 'Nouveau message';

                    // Toast in-app
                    this.showToast('message', senderName, preview, () => {
                        openChat(data.type, convId);
                    });

                    // Son
                    this.playSound('message');

                    // Notification navigateur (si onglet pas actif)
                    if (document.hidden) {
                        this.showBrowserNotif(
                            'ðŸ’¬ ' + senderName,
                            preview,
                            () => openChat(data.type, convId)
                        );
                        this.startTitleBlink('ðŸ’¬ Nouveau message !');
                    }
                });
            },

            // --- Ecouter les demandes de contact ---
            listenContactRequests() {
                let firstLoad = true;
                let knownRequests = {};

                db.ref('friendRequests/' + currentUser.uid).on('value', snapshot => {
                    const badge = document.getElementById('requestsBadge');

                    if (!snapshot.exists()) {
                        knownRequests = {};
                        if (badge) badge.classList.remove('pulse');
                        if (firstLoad) firstLoad = false;
                        return;
                    }

                    const requests = snapshot.val();
                    let newCount = 0;

                    for (const [uid, data] of Object.entries(requests)) {
                        // Ignorer les auto-accept
                        if (data.autoAccept) continue;

                        // Verifier si c'est une NOUVELLE demande
                        if (!firstLoad && !knownRequests[uid]) {
                            const pseudo = data.pseudo || 'Quelqu\'un';

                            // Toast in-app
                            this.showToast('contact', 'Demande de contact', pseudo + ' veut vous ajouter', () => {
                                // Basculer vers l'onglet Contacts
                                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                                const contactTab = document.querySelector('[data-tab="contacts"]');
                                if (contactTab) contactTab.classList.add('active');
                                document.getElementById('conversationsTab').style.display = 'none';
                                document.getElementById('contactsTab').style.display = 'block';
                            });

                            // Son
                            this.playSound('contact');

                            // Notification navigateur
                            if (document.hidden) {
                                this.showBrowserNotif(
                                    'ðŸ‘‹ Demande de contact',
                                    pseudo + ' veut vous ajouter'
                                );
                                this.startTitleBlink('ðŸ‘‹ Nouvelle demande !');
                            }

                            newCount++;
                        }

                        knownRequests[uid] = true;
                    }

                    // Pulsation du badge
                    if (badge && newCount > 0) {
                        badge.classList.add('pulse');
                        setTimeout(() => badge.classList.remove('pulse'), 5000);
                    }

                    // Nettoyer les demandes supprimees
                    for (const uid of Object.keys(knownRequests)) {
                        if (!requests[uid]) delete knownRequests[uid];
                    }

                    firstLoad = false;
                });
            }
        };

        // ==================== INCOMING CALL SYSTEM ====================
        const IncomingCallSystem = {
            _ringtoneCtx: null,
            _ringtoneInterval: null,
            _ringtoneTimeout: null,
            _currentCallData: null,
            _callListenerRef: null,

            // Sonnerie generee via Web Audio API (motif telephone)
            startRingtone() {
                this.stopRingtone();
                try {
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this._ringtoneCtx = ctx;

                    const playRingBurst = () => {
                        if (!this._ringtoneCtx || this._ringtoneCtx.state === 'closed') return;
                        // Deux tonalites alternees pour un son de sonnerie realiste
                        const t = ctx.currentTime;
                        for (let i = 0; i < 2; i++) {
                            const osc1 = ctx.createOscillator();
                            const osc2 = ctx.createOscillator();
                            const gain = ctx.createGain();

                            osc1.connect(gain);
                            osc2.connect(gain);
                            gain.connect(ctx.destination);

                            // Frequences de sonnerie telephone (440 Hz + 480 Hz)
                            osc1.frequency.value = 440;
                            osc1.type = 'sine';
                            osc2.frequency.value = 480;
                            osc2.type = 'sine';

                            gain.gain.value = 0;
                            const start = t + i * 0.5;
                            gain.gain.setValueAtTime(0.12, start);
                            gain.gain.setValueAtTime(0.12, start + 0.4);
                            gain.gain.linearRampToValueAtTime(0, start + 0.42);

                            osc1.start(start);
                            osc1.stop(start + 0.45);
                            osc2.start(start);
                            osc2.stop(start + 0.45);
                        }
                    };

                    // Jouer immediatement puis repeter toutes les 3s
                    playRingBurst();
                    this._ringtoneInterval = setInterval(playRingBurst, 3000);

                    // Arreter automatiquement apres 30s
                    this._ringtoneTimeout = setTimeout(() => {
                        this.decline();
                    }, 30000);

                } catch (e) { console.error('Ringtone error:', e); }
            },

            stopRingtone() {
                if (this._ringtoneInterval) {
                    clearInterval(this._ringtoneInterval);
                    this._ringtoneInterval = null;
                }
                if (this._ringtoneTimeout) {
                    clearTimeout(this._ringtoneTimeout);
                    this._ringtoneTimeout = null;
                }
                if (this._ringtoneCtx && this._ringtoneCtx.state !== 'closed') {
                    this._ringtoneCtx.close().catch(() => {});
                    this._ringtoneCtx = null;
                }
            },

            // Afficher l'overlay d'appel entrant
            show(callerName, convId, chatType, callerUid) {
                // Ne pas afficher si deja en appel
                if (DMVideoChat.joined) return;

                this._currentCallData = { callerName, convId, chatType, callerUid };

                document.getElementById('incomingCallAvatar').textContent = callerName.charAt(0).toUpperCase();
                document.getElementById('incomingCallName').textContent = callerName;
                document.getElementById('incomingCallOverlay').classList.add('active');

                this.startRingtone();

                // Notification navigateur si onglet inactif
                if (document.hidden) {
                    NotifSystem.showBrowserNotif(
                        'ðŸ“¹ Appel vidÃ©o entrant',
                        callerName + ' vous appelle',
                        () => window.focus()
                    );
                    NotifSystem.startTitleBlink('ðŸ“¹ Appel entrant !');
                }
            },

            // Masquer l'overlay
            hide() {
                this.stopRingtone();
                document.getElementById('incomingCallOverlay').classList.remove('active');
                this._currentCallData = null;
                NotifSystem.stopTitleBlink();
            },

            // Accepter l'appel
            accept() {
                if (!this._currentCallData) return;
                const { convId, chatType } = this._currentCallData;

                this.hide();

                // Ouvrir la conversation et demarrer l'appel video
                DMVideoChat.currentConvId = convId;
                DMVideoChat.currentCallType = chatType;

                // Afficher le nom dans la modale video
                if (chatType === 'dm') {
                    const conv = conversations[convId];
                    if (conv) {
                        const otherUserId = conv.participants ? conv.participants.find(p => p !== currentUser.uid) : null;
                        const otherPseudo = conv.otherPseudo || (otherUserId && contacts[otherUserId] && contacts[otherUserId].pseudo) || 'Utilisateur';
                        document.getElementById('vcCallName').textContent = otherPseudo;
                    }
                } else {
                    const conv = conversations[convId];
                    document.getElementById('vcCallName').textContent = (conv && conv.name) || 'Groupe';
                }

                openModal('videoCall');
            },

            // Refuser l'appel
            decline() {
                if (!this._currentCallData) return;
                this.hide();
            },

            // Ecouter les appels entrants via Firebase
            listenForCalls() {
                if (!currentUser) return;

                this._callListenerRef = db.ref('incomingCalls/' + currentUser.uid);

                this._callListenerRef.on('child_added', snap => {
                    const data = snap.val();
                    if (!data) return;

                    // Ignorer les appels vieux de plus de 35s
                    if (Date.now() - data.timestamp > 35000) {
                        snap.ref.remove();
                        return;
                    }

                    // Ignorer si c'est nous qui avons lance l'appel
                    if (data.callerUid === currentUser.uid) {
                        snap.ref.remove();
                        return;
                    }

                    this.show(data.callerName, data.convId, data.chatType, data.callerUid);

                    // Auto-nettoyage apres 35s
                    setTimeout(() => snap.ref.remove(), 35000);
                });

                // Si l'appelant annule (supprime le signal), fermer l'overlay
                this._callListenerRef.on('child_removed', snap => {
                    if (this._currentCallData && this._currentCallData.convId === snap.val()?.convId) {
                        this.hide();
                    }
                });
            },

            // Arreter l'ecoute
            stopListening() {
                if (this._callListenerRef) {
                    this._callListenerRef.off();
                    this._callListenerRef = null;
                }
                this.hide();
            }
        };

        // ==================== EMAIL NOTIFICATIONS (EmailJS) ====================
        const EmailNotifier = {
            // âš ï¸ Ã€ CONFIGURER : crÃ©e un compte sur https://www.emailjs.com (gratuit)
            // Puis remplis ces 4 valeurs :
            SERVICE_ID: 'YOUR_EMAILJS_SERVICE_ID',
            TEMPLATE_MESSAGE_ID: 'YOUR_TEMPLATE_MESSAGE',
            TEMPLATE_CONTACT_ID: 'YOUR_TEMPLATE_CONTACT',
            PUBLIC_KEY: 'YOUR_EMAILJS_PUBLIC_KEY',

            COOLDOWN_MS: 30 * 60 * 1000, // 30 min entre chaque email par utilisateur
            _enabled: false,

            init() {
                if (typeof emailjs === 'undefined') return;
                if (this.PUBLIC_KEY && this.PUBLIC_KEY !== 'YOUR_EMAILJS_PUBLIC_KEY') {
                    emailjs.init(this.PUBLIC_KEY);
                    this._enabled = true;
                    console.log('ðŸ“§ Email notifications activÃ©es');
                } else {
                    console.log('ðŸ“§ EmailJS non configurÃ© - emails dÃ©sactivÃ©s');
                }
            },

            async notifyNewMessage(recipientUid, senderPseudo, messagePreview) {
                if (!this._enabled) return;
                if (recipientUid === currentUser.uid) return;

                try {
                    // VÃ©rifier le cooldown
                    if (!await this._shouldSend(recipientUid, 'msg')) return;

                    // VÃ©rifier les prÃ©fÃ©rences du destinataire
                    const prefSnap = await db.ref('users/' + recipientUid + '/emailNotifications').once('value');
                    if (prefSnap.val() === false) return;

                    // RÃ©cupÃ©rer l'email du destinataire
                    const emailSnap = await db.ref('users/' + recipientUid + '/email').once('value');
                    const recipientEmail = emailSnap.val();
                    if (!recipientEmail) return;

                    // RÃ©cupÃ©rer le pseudo du destinataire
                    const pseudoSnap = await db.ref('users/' + recipientUid + '/pseudo').once('value');
                    const recipientPseudo = pseudoSnap.val() || 'Utilisateur';

                    // Envoyer l'email via EmailJS
                    await emailjs.send(this.SERVICE_ID, this.TEMPLATE_MESSAGE_ID, {
                        to_email: recipientEmail,
                        to_name: recipientPseudo,
                        from_name: senderPseudo,
                        message_preview: messagePreview.substring(0, 100),
                        app_url: window.location.origin + '/messagerie.html'
                    });

                    // Marquer l'envoi pour le cooldown
                    await this._markSent(recipientUid, 'msg');
                    console.log('ðŸ“§ Email envoyÃ© Ã ', recipientPseudo);

                } catch (e) {
                    console.error('ðŸ“§ Erreur envoi email:', e);
                }
            },

            async notifyContactRequest(recipientUid, senderPseudo) {
                if (!this._enabled) return;
                if (recipientUid === currentUser.uid) return;

                try {
                    if (!await this._shouldSend(recipientUid, 'contact')) return;

                    const prefSnap = await db.ref('users/' + recipientUid + '/emailNotifications').once('value');
                    if (prefSnap.val() === false) return;

                    const emailSnap = await db.ref('users/' + recipientUid + '/email').once('value');
                    const recipientEmail = emailSnap.val();
                    if (!recipientEmail) return;

                    const pseudoSnap = await db.ref('users/' + recipientUid + '/pseudo').once('value');
                    const recipientPseudo = pseudoSnap.val() || 'Utilisateur';

                    await emailjs.send(this.SERVICE_ID, this.TEMPLATE_CONTACT_ID, {
                        to_email: recipientEmail,
                        to_name: recipientPseudo,
                        from_name: senderPseudo,
                        app_url: window.location.origin + '/messagerie.html'
                    });

                    await this._markSent(recipientUid, 'contact');
                    console.log('ðŸ“§ Email demande de contact envoyÃ© Ã ', recipientPseudo);

                } catch (e) {
                    console.error('ðŸ“§ Erreur envoi email contact:', e);
                }
            },

            async _shouldSend(uid, type) {
                try {
                    const snap = await db.ref('emailCooldowns/' + uid + '/' + type).once('value');
                    if (!snap.exists()) return true;
                    return (Date.now() - snap.val()) > this.COOLDOWN_MS;
                } catch (e) {
                    return false;
                }
            },

            async _markSent(uid, type) {
                try {
                    await db.ref('emailCooldowns/' + uid + '/' + type).set(Date.now());
                } catch (e) {
                    console.error('ðŸ“§ Erreur cooldown:', e);
                }
            }
        };

        // ==================== EMOJI PICKER ====================
        const emojiData = {
            'ðŸ˜€ Smileys': ['ðŸ˜€','ðŸ˜ƒ','ðŸ˜„','ðŸ˜','ðŸ˜†','ðŸ˜…','ðŸ¤£','ðŸ˜‚','ðŸ™‚','ðŸ˜Š','ðŸ˜‡','ðŸ¥°','ðŸ˜','ðŸ¤©','ðŸ˜˜','ðŸ˜—','ðŸ˜‹','ðŸ˜›','ðŸ˜œ','ðŸ¤ª','ðŸ˜','ðŸ¤—','ðŸ¤­','ðŸ¤«','ðŸ¤”','ðŸ˜','ðŸ˜‘','ðŸ˜¶','ðŸ˜','ðŸ˜’','ðŸ™„','ðŸ˜¬','ðŸ˜®â€ðŸ’¨','ðŸ¤¥','ðŸ˜Œ','ðŸ˜”','ðŸ˜ª','ðŸ¤¤','ðŸ˜´','ðŸ˜·','ðŸ¤’','ðŸ¤•','ðŸ¤¢','ðŸ¤®','ðŸ¥µ','ðŸ¥¶','ðŸ˜µ','ðŸ¤¯','ðŸ¥³','ðŸ¥¸','ðŸ˜Ž','ðŸ¤“','ðŸ§'],
            'â¤ï¸ Coeurs': ['â¤ï¸','ðŸ§¡','ðŸ’›','ðŸ’š','ðŸ’™','ðŸ’œ','ðŸ–¤','ðŸ¤','ðŸ¤Ž','ðŸ’”','â£ï¸','ðŸ’•','ðŸ’ž','ðŸ’“','ðŸ’—','ðŸ’–','ðŸ’˜','ðŸ’','ðŸ’Ÿ','â™¥ï¸','ðŸ«¶','ðŸ¤Ÿ','ðŸ¤™','ðŸ’ª'],
            'ðŸ‘‹ Gestes': ['ðŸ‘‹','ðŸ¤š','ðŸ–ï¸','âœ‹','ðŸ––','ðŸ‘Œ','ðŸ¤Œ','ðŸ¤','âœŒï¸','ðŸ¤ž','ðŸ¤Ÿ','ðŸ¤˜','ðŸ¤™','ðŸ‘ˆ','ðŸ‘‰','ðŸ‘†','ðŸ‘‡','â˜ï¸','ðŸ‘','ðŸ‘Ž','âœŠ','ðŸ‘Š','ðŸ¤›','ðŸ¤œ','ðŸ‘','ðŸ™Œ','ðŸ‘','ðŸ¤²','ðŸ¤','ðŸ™'],
            'ðŸŽ‰ Fete': ['ðŸŽ‰','ðŸŽŠ','ðŸŽˆ','ðŸŽ','ðŸŽ€','ðŸª…','ðŸŽ†','ðŸŽ‡','âœ¨','ðŸŒŸ','â­','ðŸ†','ðŸ¥‡','ðŸ¥ˆ','ðŸ¥‰','ðŸ…','ðŸŽ–ï¸','ðŸŽ—ï¸','ðŸŽ¯','ðŸŽ®','ðŸŽ²','ðŸŽ­','ðŸŽ¨','ðŸŽ¬','ðŸŽ¤','ðŸŽ§','ðŸŽµ','ðŸŽ¶','ðŸŽ¹','ðŸŽ¸','ðŸŽº','ðŸ¥'],
            'ðŸ¶ Animaux': ['ðŸ¶','ðŸ±','ðŸ­','ðŸ¹','ðŸ°','ðŸ¦Š','ðŸ»','ðŸ¼','ðŸ¨','ðŸ¯','ðŸ¦','ðŸ®','ðŸ·','ðŸ¸','ðŸµ','ðŸ™ˆ','ðŸ™‰','ðŸ™Š','ðŸ’','ðŸ”','ðŸ§','ðŸ¦','ðŸ¤','ðŸ¦†','ðŸ¦…','ðŸ¦‰','ðŸ¦‡','ðŸº','ðŸ—','ðŸ´','ðŸ¦„','ðŸ','ðŸ›','ðŸ¦‹','ðŸŒ','ðŸž'],
            'ðŸ” Nourriture': ['ðŸ','ðŸŽ','ðŸ','ðŸŠ','ðŸ‹','ðŸŒ','ðŸ‰','ðŸ‡','ðŸ“','ðŸ«','ðŸ’','ðŸ‘','ðŸ¥­','ðŸ','ðŸ¥¥','ðŸ¥','ðŸ…','ðŸ¥‘','ðŸ”','ðŸŸ','ðŸ•','ðŸŒ­','ðŸ¥ª','ðŸŒ®','ðŸŒ¯','ðŸ¥—','ðŸ¿','ðŸ§','ðŸ©','ðŸª','ðŸŽ‚','ðŸ°','â˜•','ðŸµ','ðŸ§ƒ','ðŸº','ðŸ·','ðŸ¥‚','ðŸ¾'],
            'âš¡ Symboles': ['ðŸ’¯','ðŸ”¥','âš¡','ðŸ’«','âœ…','âŒ','âš ï¸','ðŸš«','â™»ï¸','ðŸ’¤','ðŸ’¬','ðŸ’­','ðŸ—¯ï¸','ðŸ‘ï¸â€ðŸ—¨ï¸','ðŸ””','ðŸ”•','â“','â—','â€¼ï¸','â‰ï¸','ðŸ†—','ðŸ†•','ðŸ”','ðŸ”œ','ðŸ”„','â–¶ï¸','â¸ï¸','â¹ï¸','ðŸ”´','ðŸŸ ','ðŸŸ¡','ðŸŸ¢','ðŸ”µ','ðŸŸ£','âš«','âšª','ðŸŸ¤','ðŸ”˜']
        };

        (function initEmojiPicker() {
            const toggle = document.getElementById('emojiToggle');
            const picker = document.getElementById('emojiPicker');
            const grid = document.getElementById('emojiGrid');
            const categories = document.getElementById('emojiCategories');
            const input = document.getElementById('messageInput');

            // Creer les boutons de categories
            const catNames = Object.keys(emojiData);
            catNames.forEach((cat, i) => {
                const btn = document.createElement('button');
                btn.className = 'emoji-cat-btn' + (i === 0 ? ' active' : '');
                btn.textContent = cat.split(' ')[0];
                btn.title = cat;
                btn.addEventListener('click', () => {
                    categories.querySelectorAll('.emoji-cat-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    renderEmojis(cat);
                });
                categories.appendChild(btn);
            });

            // Afficher les emojis d'une categorie
            function renderEmojis(cat) {
                grid.innerHTML = '';
                emojiData[cat].forEach(emoji => {
                    const span = document.createElement('span');
                    span.textContent = emoji;
                    span.addEventListener('click', () => {
                        input.value += emoji;
                        input.focus();
                    });
                    grid.appendChild(span);
                });
            }

            // Afficher la premiere categorie par defaut
            renderEmojis(catNames[0]);

            // Toggle ouverture/fermeture
            toggle.addEventListener('click', (e) => {
                e.stopPropagation();
                picker.classList.toggle('open');
            });

            // Fermer en cliquant ailleurs
            document.addEventListener('click', (e) => {
                if (!picker.contains(e.target) && e.target !== toggle) {
                    picker.classList.remove('open');
                }
            });
        })();

        // ==================== INIT NOTIFICATIONS ====================
        const _origInitApp = initApp;
        initApp = function() {
            _origInitApp();
            NotifSystem.init();
            EmailNotifier.init();
            IncomingCallSystem.listenForCalls();
        };
    </script>

    <!-- Bouton Partager Flottant -->
    <div class="share-fab" id="shareFab">
        <button class="share-fab-btn" id="shareFabBtn" aria-label="Partager cette page" data-i18n-aria="share.fab.aria">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z"/></svg>
        </button>
        <div class="share-fab-menu" id="shareFabMenu">
            <button class="share-fab-menu-item" onclick="shareFabWhatsApp()">
                <svg viewBox="0 0 24 24" fill="#25D366"><path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413z"/></svg>
                <span data-i18n="share.fab.whatsapp">WhatsApp</span>
            </button>
            <button class="share-fab-menu-item" onclick="shareFabX()">
                <svg viewBox="0 0 24 24" fill="#e8e8e8"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
                <span data-i18n="share.fab.x">X (Twitter)</span>
            </button>
            <button class="share-fab-menu-item" onclick="shareFabCopy()">
                <span class="sfm-icon">ðŸ”—</span>
                <span data-i18n="share.fab.copy" id="shareFabCopyText">Copier le lien</span>
            </button>
        </div>
    </div>
    <script>
    (function() {
        var fabBtn = document.getElementById('shareFabBtn');
        var fabMenu = document.getElementById('shareFabMenu');
        fabBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            if (navigator.share) {
                navigator.share({ title: document.title, url: window.location.href }).catch(function(){});
            } else {
                fabMenu.classList.toggle('open');
            }
        });
        document.addEventListener('click', function(e) {
            if (!document.getElementById('shareFab').contains(e.target)) {
                fabMenu.classList.remove('open');
            }
        });
    })();
    function shareFabWhatsApp() {
        window.open('https://wa.me/?text=' + encodeURIComponent(document.title + ' ' + window.location.href), '_blank');
    }
    function shareFabX() {
        window.open('https://x.com/intent/post?text=' + encodeURIComponent(document.title) + '&url=' + encodeURIComponent(window.location.href), '_blank');
    }
    function shareFabCopy() {
        navigator.clipboard.writeText(window.location.href).then(function() {
            var el = document.getElementById('shareFabCopyText');
            var orig = el.textContent;
            el.textContent = 'âœ… CopiÃ© !';
            setTimeout(function() { el.textContent = orig; }, 2000);
        });
    }
    </script>

    <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js').catch(() => {});
    }
    </script>
</body>
</html>
